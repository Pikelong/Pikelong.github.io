{"pages":[],"posts":[{"title":"毛概","text":"公共课 各大理论被写入党章确立为党的指导思想的时间 马列主义——一大 毛泽东思想——七大 邓小平理论——十五大 三个代表重要思想——十六大 科学发展观——十八大 习近平新时代中国特色社会主义思想——十九大 第一章毛泽东思想的历史地位 马克思主义中国化的第一个理论成果 中国革命和建设的科学指南 中国共产党和中国人民宝贵的精神财富毛泽东思想的形成过程时代背景：战争与革命的时代主题 实践基础：中国共产党领导的革命和建设的实践 形成：第一次国内革命战争，P4 成熟：遵义会议之后到解放战争之前 发展：解放战争时期到新中国成立之后 毛泽东思想的主要内容和活的灵魂主要内容 新民主主义革命理论 社会主义革命和社会主义建设理论 革命军队建设和军事战略的理论 政策和策略的理论 思想政治工作和文化工作的理论 党的建设理论活的灵魂贯穿于毛泽东思想的各个组成部分的立场、观点和方法，是毛泽东思想的活的灵魂，他们有三个基本方面： 实事求是 群众路线 独立自主 实事求是、群众路线、独立自主是我们党进行革命、建设和改革的出发点、根本点和立足点 第二章新民主主义革命理论形成的依据在半殖民地半封建的近代中国，占支配地位的主要矛盾是帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾，而帝国主义和中华民族的矛盾，是各种矛盾中最主要的矛盾 中国革命仍然是资产阶级革命，但经历了从旧民主主义革命向新民主主义革命的转变，以五四运动的爆发为标志 新民主主义革命的总路线 总路线的内容 无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命 革命的对象 帝国主义是中国社会进步和发展的最大障碍，是近代中国贫穷落后和一切灾难祸害的总根源 封建地主阶级是中国经济现代化和政治民主化的主要障碍 新民主主义革命的动力 无产阶级、农民阶级、城市小资产阶级、民族资产阶级 无产阶级是中国革命最基本的动力 农民是中国革命的主力军 城市小资产阶级是无产阶级的可靠同盟者 民族资产阶级也是中国革命的动力之一 新民主主义革命的领导力量 无产阶级及其政党实现对各革命阶级的领导，必须建立以工农联盟为基础的广泛的统一战线（群众基础），这是实现领导权的关键 无产阶级在同资产阶级建立统一战线时，必须坚持独立自主的原则，这是坚持领导权的基本策略 建立一支无产阶级领导的以农民为主体的强大的革命武装，是保证领导权的坚强支柱 加强无产阶级政党的建设，是实现领导权的根本保证了解新民主主义革命的基本纲领 政治纲领新民主主义国家的国体：无产阶级领导的以工农联盟为基础，包括小资产阶级、民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政——各革命阶级联合专政政体：民主集中制的人民代表大会制度 经济纲领没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业 文化纲领新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化 了解新民主主义革命的道路农村包围城市，武装夺取政权中国革命走农村包围城市、武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村革命根据地建设三者之间的关系 土地革命是民主革命的基本内容 武装斗争是中国革命的主要形式，是农村根据地建设和土地革命的强有力保证 农村革命根据地市场中国革命的战略阵地，是进行武装斗争和开展土地革命的依托新民主主义革命的三大法宝 统一战线 建立巩固的工农联盟 正确对待资产阶级 采取区别对待的方针 坚持独立自主的原则 武装斗争 坚持党对军队的绝对领导 建设全心全意为人民服务的人民军队 坚持正确的战略战术原则 党的建设 伟大工程只有它 必须把思想建设放在党的建设的首位 必须在任何时候都重视党的组织建设 必须重视党的作风建设 必须联系党的政治路线加强党的建设 第三章新民主主义社会是一个过渡性的社会由经济决定 新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会 主要的经济成分：社会主义经济、个体经济、资本主义经济主要的阶级构成：工人阶级、农民阶级和其他小资产阶级、民族资产阶级 工人阶级和资产阶级的矛盾逐步成为我国社会的主要矛盾 党在过渡时期的总路线逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造 主要内容被概括为“一化三改”。“一化”即社会主义工业化，“三改”即对个体农业、手工业和资本主义工商业的社会主义改造。它们之间相互联系，不可分离 了解适合中国特点的社会主义特点的改造道路农业手工业的社会主义改造对农业的目标：将个体所有制改造成集体所有制 积极引导农民组织起来，走互助合作道路 个体经济的积极性 互助合作的积极性 遵循自愿互利、典型示范和国家帮助的原则 正确分析农村的阶级和阶层状况，制定正确的阶级政策 贫下中农是当在农村的依靠力量 坚持积极领导、稳步前进的方针，采取循序渐进的步骤 三个发展阶段 互助组 初级社 高级社 对手工业的方针：积极领导、稳步前进三个步骤 第一步是办手工业供销小组 第二部是办手工业功效合作社 第三步是建立手工业生产合作社 资本主义工商业的改造 第一，用和平赎买的方法改造资本主义工商业 三个有利于 有利于发挥私营工商业在国计民生方面的积极作用 有利于争取和团结民族资产阶级 有利于发挥民族资产阶级中大多数人的知识、才能、技术专长和管理经验 能够和平赎买的原因 民族资产阶级具有两面性 中国共产党和民族资产阶级长期保持着统一战线的关系 我国已经有了以工人阶级为领导、工农联盟为基础的人民民主专政的国家政权 第二，采取从低级到高级的国家资本主义的过渡形式 低级：委托加工、计划订货、统购包销、经销代销 高级：公私合营 三个步骤： 初级形式 四马分肥 个别企业的公私合营 四马分肥 全行业的公私合营 第三，把资本主义工商业者改造成为自食其力的社会主义劳动者 社会主义改造的历史经验 第一，坚持社会主义工业化建设与社会主义改造同时并举 第二，采取积极引导、逐步过渡的方式 第三，用和平方法进行改造社会主义基本制度的确立时间：1956年底表现： 我国社会经济结构发生了根本变化 政治建设取得巨大成就，例：1954年颁布《中华人民共和国宪法》 确立的意义 极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展 使广大人民真正成为国家的主人 使占世界人口的四分之一的东方大国进入了社会主义社会，这是世界社会主义发展史上又一个历史性的伟大胜利 是以毛泽东为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果 第四章了解调动一切积极因素，为社会主义事业服务1956年毛泽东发表了《论十大关系》 调动一切积极因素为社会主义事业服务，必须坚持中国共产党的领导 正确认识和处理社会主义社会矛盾的思想在社会主义社会中，基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾 了解走中国工业化道路的思想以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针。一系列“两条腿走路”：重工业和轻工业同时并举，中央工业和地方工业同时并举，沿海工业和内地工业同时并举，大型企业和中小型企业同时并举 掌握社会主义建设道路初步探索的重要意义 第一，巩固和发展了我国的社会主义制度 第二，为开创中国特色主义思路提供了宝贵经验、理论准备、物质基础 丰富了科学社会主义的理论与实践 第五章了解邓小平理论的形成条件时代背景：和平与发展成为时代主题 历史依据：社会主义建设的经验教训 现实依据：改革开放和现代化建设的实践 全球性的战略问题 和平问题 发展问题（核心问题） 了解邓小平理论形成的过程党的十一届三中全会后，重新确立了解放思想，实事求是的思想路线，确定把党的重点工作转移到社会主义现代化建设上来，作出实行改革开放的重大决策 十二大提出建设有中国特色的社会主义 十三大第一次比较系统的阐述了我国社会主义初级阶段理论，第一次对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成 1992年，南方谈话。社会主义的本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕是邓小平理论集大成之作。 十四大邓小平理论逐步走向成熟。 党的十五大，正式提出邓小平理论这一概念，把邓小平理论确立为党的指导思想。 1999年，正式把邓小平理论载入宪法。 掌握邓小平理论回答的基本问题什么是社会主义，怎样建设社会主义 邓小平理论的主要内容 解放思想、实事求是的思想路线 社会主义初级阶段理论 党的基本路线 领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗 奋斗目标：建设富强、民主、文明的社会主义现代化国家 基本途径：一个中心，两个基本点。以经济建设为中心，坚持四项基本原则，坚持改革开放 领导力量和依靠力量：领导和团结全国各族人民 党的优良传统：自力更生，艰苦创业 社会主义根本任务的理论 社会主义的根本任务是发展生产力 科学技术是第一生产力 “三步走”战略 第一步 1990年国民生产总值比1980年翻一番，解决人民的温饱问题 第二步 1991年到20世纪末，国民生产总值再翻一番，达到小康水平 第三步 到21世纪中叶，国民生产总值再翻两番，达到中等发达国家水平，基本实现现代化 改革开放理论 新时代最鲜明的特点是改革开放。 改革是中国的第二次革命 改革是社会主义社会发展的直接动力 改革的实质和目标就是要从根本上改变束缚我国生产力发展的经济体制 开放从根本上也是改革，开放也是基本国策 社会主义市场经济理论 “两手抓，两手都要硬” 物质文明和精神文明两手抓 一国两制 中国问题的关键在于党 理解邓小平理论的历史地位 是马克思列宁主义、毛泽东思想的继承和发展 是中国特色社会主义理论体系的开篇之作 是改革开放和社会主义现代化建设的科学指南 第六章了解三个代表重要思想的形成过程在2000年在广东考察，首次对三个代表提出了比较全面的阐述。 党的十五届五中全会，要以“三个代表”作为检验我们各项工作是否合格的根本标准 2001年，中国共产党成立80周年，全面阐述了三个代表重要思想的内涵和内容。 十六大全面阐述，并写入党章 理解三个代表总要思想的核心观点 始终代表中国先进生产力的发展要求 科学技术是第一生产力，是先进生产力的集中体现和主要标志 始终代表中国先进文化的前进方向 弘扬爱国主义精神，以为人民服务为核心、以集体主义为原则、以诚实守信为重点 始终代表中国最广大人民的根本利益 党来自于人民，植根于人民，服务于人民。党的全部任务和责任，就是为实现人民群众的根本利益而奋斗 党作为执政党，面临的最根本的课题，是能不能始终代表最广大人民的根本利益，始终全心全意为人民服务 党除了最广大人民的利益，没有自己特殊的利益 我们党进行的一切奋斗，归根到底都是为了最广大人民的根本利益。党的一切工作，必须以最广大人民的根本利益为最高标准 党和国家的一切工作和方针政策，都要以是否符合最广大人民群众的根本利益为最高衡量标准 了解三个代表重要思想的主要内容五个方面 发展是当执政兴国的第一要务 建立社会主义市场经济体制 全面建设小康社会 建设社会主义政治文明 最根本的是要坚持党的领导、人民当家作主和依法治国的有机统一 推进党的建设新的伟大工程 坚持党的领导，核心是坚持党的先进性 理解三个代表重要思想的历史地位 是中国特色社会主义理论体系的接续发展 加强和改进了党的建设，推进中国特色社会主义事业的强大理论武器 第七章了解科学发展观的科学内涵第一要义是发展，核心是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。 了解科学发展观的主要内容 加快转变经济发展方式 发展社会主义民主政治 社会主义民主政治的本质和核心是人民当家作主 推进社会主义文化强国建设 构建社会主义和谐社会 民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐共处，是构建社会主义和谐社会的总要求 推进生态文明建设 全面提高党的建设科学化水平 执政能力建设是党执政后的一项根本建设 保持和发展党的先进性是马克思主义政党自身建设的根本任务和永恒课题 理解科学发展观的历史地位 是中国特色社会主义理论体系的接续发展 科学发展观强调坚持以经济建设为中心，把发展生产力作为首要任务，把经济发展作为一切发展的前提 发展中国特色社会主义必须长期坚持的指导思想 第八章了解历史性成就（太多了，看一下就可以）增强政治意识、大局意识、核心意识、看齐意识 理解社会主要矛盾的变化十九大明确指出，我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾 十九大对新的历史方位的判断中国特色社会主义进入了新时代，这是我国发展新的历史方位 了解习近平社会主义新时代的核心要义和丰富内涵核心要义：坚持和发展中国特色社会主义 丰富内涵：最重要、最核心的内容就是党的十九大报告概括的“八个明确”明确中国特色社会主义事业总体布局是“五位一体”，战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导 了解坚持和发展中国特色社会主义的基本方略十四个坚持 党的领导、人民当家作主、依法治国有机统一是社会主义政治发展的必然要求 全面依法治国是中国特色社会主义的本质要求和重要保障 绿水青山就是金山银山 “八个明确”是指导思想层面的表述，重点讲的是怎么看“十四个坚持”是行动纲领层面的表述，重点讲的是怎么办 理解习近平新时代中国特色社会主义思想的历史地位 马克思主义中国化最新成果 新时代的精神旗帜 实现中华民族伟大复兴的行动指南 习近平新时代中国特色社会主义思想是党和国家必须长期坚持的指导思想 是党的意志、国家意志和人民意志集的中体现 为新时代治国理政提供了基本遵循 为全面从严治党、把党建设成为中国特色社会主义事业的坚强领导核心提供了强大思想武器 第九章实现中华民族伟大复兴，就是中华民族近代以来最伟大的梦想 了解中国梦的科学内涵中国梦是国家情怀、民族情怀、人民情怀相统一的梦 中国梦归根到底是人民的梦 中国梦是国家的梦、民族的梦，也是每一个中国人的梦 了解奋力实现中国梦实现中国梦必须走中国道路、弘扬中国精神，凝聚中国力量 了解实现社会主义强国两步走的具体战略两个一百年：到建党100年时建成惠及十几亿人口的更高水平的小康社会；到新中国成立100年时基本实现现代化，建成社会主义现代化国家 第二个一百年奋斗目标第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗15年，基本实现社会主义现代化第二个阶段，从2035年到本世纪中叶，在基本实现现代化的基础上，再奋斗15年，把我国建成富强民主文明和谐美丽的社会主义现代化强国 第十章 “五位一体”总体布局经济建设、政治建设、文化建设、社会建设、生态文明建设 建设现代化经济体系 贯彻新发展理念 党的十八届五中全会坚持以人民为中心的发展思想，鲜明提出了创新、协调、绿色、开放、共享的新发展理念 坚持创新发展，是应对发展环境变化、增强发展动力、把握发展主动权，更好引领新常态的根本之策 坚持协调发展，要着力推动区域协调发展、城乡协调发展、物质文明和精神文明协调发展，推动经济建设和国防建设融合发展 绿色是永续发展的必要条件 开放是国家繁荣发展的必由之路 共享是中国特色社会主义的本质要求 四个方面 全民共享 全面共享 共建共享 渐进共享 深化供给侧结构性改革 方针：坚持质量第一、效益优先 主线：供给侧结构性改革 推动经济发展质量变革、效率变革、动力变革，提高全要素生产率 培育新增长点、行程新动能 破除无效供给。培育新动能。降低实体经济成本。优化存量资源配置，提质升级存量供给，扩大优质增量供给。 建设知识性、技能型、创新型劳动者大军 “三去一降一补”：去产能、去库存、去杠杆、降成本、补短板 建设现代化经济体系的主要任务 我国经济已由高速增长阶段转向高质量发展阶段，正处在转变发展方式、优化经济结构、转换增长动力的攻关期 建设现代化经济体系，必须坚持质量第一、效益优先，推动经济发展质量变革、效率变革、动力变革 要建设创新引领、协同发展的产业体系 要建设统一开放、竞争有序的市场体系 要建设体现效率、促进公平的收入分配体现 要建设彰显优势、协调联动的城乡区域发展体现 要建设资源节约、环境友好的绿色发展体系 要建设多元平衡、安全高效的全面开放体系 同时要突出抓好以下几个方面工作 大力发展实体经济 加快实施创新驱动发展战略 建立以企业为主体、市场为导向、产学研深度融合的技术创新体系 激发各类市场主体活力 积极推动城乡区域协调发展 着力发展开放型经济 加快完善社会主义市场经济体制 掌握中国特色社会主义政治发展道路必须坚持党的领导，人民当家做主、依法治国有机统一党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式，三者统一于我国社会主义民主政治伟大实践 了解人民当家做主人民代表大会制度是我国根本政治制度，是符合中国国情、体现中国社会主义国家性质、能够保证人民当家作主的根本政治制度和最高实现形式 中国共产党领导的多党合作和政治协商制度是我国的一项基本政治制度 民族区域自治制度是我国的一项基本政治制度。 基层群众自治制度是我国的一项基本政治制度。 了解爱国统一战线长期共存、互相监督、肝胆相照、荣辱与共 （文化）了解培育和践行社会主义核心价值观国家层面：富强、民主、文明、和谐社会层面：自由、平等、公正、法治公民层面：爱国、敬业、诚信、友善 了解文化自信坚定文化自信，事关国运兴衰，事关文化安全，事关民族精神的独立性 了解提高、保障和改善民生水平坚持以人民为中心的发展思想五个措施 第一，优先发展教育事业 第二，提高就业质量和人民收入水平 第三，加强社会保障体系建设 第四，坚决打赢脱贫攻坚战 第五，实施健康中国战略 坚持总体国家安全观总体国家安全观是指坚持国家利益至上，以人民安全为宗旨，以政治安全为根本，以经济安全为基础，以军事、文化、社会安全为保障，以促进国际安全为依托，维护各领域国家安全，构建国家安全体系，走中国特色国家安全道路 理解和掌握人与自然和谐共生，形成人与自然和谐发展的新格局生态文明的核心是坚持人与自然和谐共生。人与自然的关系经历了从依附自然到利用自然、再到人与自然和谐共生的发展历程。原始文明——农业文明——工业文明——生态文明 尊重自然是首要态度 顺应自然是基本原则 保护自然是重要责任 建设社会主义生态文明就是要实现人与自然和谐发展，就是要建设以资源环境承载力为基础、以自然规律为准则、以可持续发展为目标的资源节约型、环境友好型社会，努力走向社会主义生态文明 新格局：四个方面 把节约资源放在首位 坚持保护优先、自然恢复为主。在环保工作中，把预防为主、源头治理放在首位；在生态系统保护和修复中，把利用自然力修复生态系统放在首位 着力推进绿色发展、循环发展、低碳发展 行程节约资源和保护环境的空间格局、产业结构、生产方式、生活方式 加快生态文明体制改革建设生态文明是一场涉及生产方式、生活方式、思维方式和价值观念的革命性变革 构建政府为主导、企业为主体、社会组织和公众共同参与的环境治理体系 完成生态保护红线、永久基本农田、城镇开发边界三条控制线划定工作 第十四章 坚持和加强党的领导中国共产党的领导地位是历史和人民的选择中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队，是中国特色社会主义事业的领导核心（性质）三项革命 完成新民主主义革命，建立了中华人民共和国 完成社会主义革命，确立了社会主义基本制度 进行改革开放新的伟大革命三个蓬勃生机 让中华文明在现代化进程中焕发出新的蓬勃生机 让科学社会主义在21世纪焕发出新的蓬勃生机 使中华民族焕发出新的蓬勃生机 了解中国特色社会主义的本质特征 党的领导是中国特色社会主义最本质的特征 由科学社会主义的理论逻辑决定 由中国特色社会主义产生与发展的历史逻辑决定 由中国特色社会主义迈向新征程的时间逻辑决定 党的领导是中国特色社会主义制度的最大优势 中国特色社会主义制度是党领导人民创建的 根本政治制度：人民代表大会制度 基本政治制度： 中国共产党领导的多党合作和政治协商制度 民族区域自治制度 基层群众自治制度 总目标：完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化 党的领导是充分发挥中国特色社会主义制度优势的根本保障 党的自身优势是中国特色社会主义制度优势的主要来源 理论优势：马克思主义 政治优势：坚定崇高的政治理想、政治理念和百折不挠的革命意志 组织优势： 制度优势：民主集中制 作风优势：联系群众 理解新时代中国共产党的历史使命党的最高理想和最终目标：实现共产主义新时代中国共产党的历史使命：统揽伟大斗争、伟大工程、伟大事业、伟大梦想,在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴的中国梦 党的建设是新的伟大工程（毛泽东首先提出） 伟大斗争、伟大工程、伟大事业、伟大梦想是一个紧密联系、相互贯通、相互作用、有机统一的整体，统一于新时代坚持和发展中国特色社会主义伟大实践。 伟大梦想是目标 伟大斗争是手段 伟大工程是保障 伟大事业是主题 坚持党对一切工作的领导党是最高政治领导力量 第一，这是马克思主义政党的基本要求 第二，这是对党领导革命、建设和改革历史经验的深刻总结 第三，这是推进伟大事业的根本保证 确保党始终总揽全局协调各方 必须增强政治意识、大局意识、核心意识、看齐意识 必须坚持和完善党的领导体制机制 必须坚持党的民主集中制原则 全面增强党的执政本领 一是增强学习本领 二是增强政治领导本领 三是增强改革创新本领 四是增强科学发展本领 五是增强依法执政本领 六是增强群众工作本领 七是增强狠抓落实本领 八是增强驾驭风险本领","link":"notes/%E6%AF%9B%E6%A6%82/"},{"title":"数据结构","text":"信息技术 逻辑结构 线性结构 集合结构 树形结构 图形结构 123456789graph g{逻辑结构--线性结构--线性表--栈线性表--队列逻辑结构--非线性结构--集合非线性结构--树形结构--二叉树树形结构--一般树非线性结构--图形结构--有向图图形结构--无向图} 物理结构（存储结构） 顺序存储（数组，顺序表） 链式存储（链表） 索引存储 散列存储如何判断某种结构是逻辑结构还是存储结构或数据结构？当一个结构，如数组、链表、树、图，在逻辑结构中只有一种定义，而在物理结构中却有两种选择，那么这个结构就属于逻辑结构； 相反，当此结构在原有基础上加上了某种限定，使得其在物理结构中只有一种定义，那么这个结构就属于物理（存储）结构； 举例1：栈属于什么结构？ 分析：栈在逻辑结构中只能属于线性结构，而在物理结构中它可以使用顺序存储（数组），也可以使用链式存储（链表），所以说栈是一种逻辑结构。 举例2：线索二叉树属于什么结构？ 分析：首先，可以得到二叉树是一种逻辑结构，但是线索二叉树是加上线索后的链表结构（不能用顺序存储），也就是说，它是计算机内部的只有一种存储结构，所以是物理结构。 算法算法满足 输入 输出 确定性：对于相同的输入只能得出相同的输出 有穷性 可行性 衡量算法的标准 Correctness 正确性 Readability 可读性 Robustness 健壮性 Efficiency 效率与低存储量需求（核心的） 衡量效率的指标 时间复杂度 空间复杂度 时间复杂度大O表示法一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为**T(n)*，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算（最深层循环内*的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度f(n)来分析算法的时间复杂度。因此，算法的时间复杂度记为$$T(n)=O(f(n))$$O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和$n_0$，使得当$n\\geqslant n_0$时，都满足$0\\leqslant T(n)\\leqslant Cf(n)$.图示如下： 可以总结为:T(n)增长率小于等于f(n) 最坏时间复杂度是指在最坏情况下，算法的时间复杂度 平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间 最好时间复杂度是指在最好情况下，算法的时间复杂度 一般总是考虑最坏时间复杂度，以保证算法的运行时间不会比它更长 加法规则$$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$$ 乘法规则$$T(n)=T_1(n)\\times T_2(n)=O(f(n))\\times O(g(n))=O(f(n)\\times g(n))$$ 常见的时间复杂度$$O(1)&lt;O(\\log_2 n)&lt;O(n)&lt;O(n\\log_2 n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$ T(n)写法 忽略常数不能写O(2n^2^)，得写成O(n^2^) 忽略低次项不能写O(n^2^+n)，得写成O(n^2^) 空间复杂度算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为$S(n)=O(g(n))$ 算法原地工作是指算法所需的辅助空间为常量，即O(1) 第二章 线性表123456graph a{ node [shape=none] 线性表--顺序存储--顺序表 线性表--链式存储--单链表,双链表,循环链表--指针实现 链式存储--静态链表（借助数组实现）} 定义和基本操作定义线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当n=0时该线性表是一个空表。若用L命名线性表，则其一般表示为$$L=(a_1,a_2,…,a_i,a_{i+1},…,a_n)$$ 特点 表中元素个数有限 表中元素具有逻辑上的顺序性，在序列中各元素排序有其先后次序 表中元素都是数据元素，每个元素都是单个元素 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容 注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两种属于不同层面的概念，因此不要将其混淆 基本操作 InitList(&amp;L): 初始化表。构造一个空的线性表 Length(L): 求表长。返回线性表的长度 LocateElem(L,e): 按值查找操作。在表中查找具有给定关键字值的元素 GetElem(L,i): 按位查找操作。获取表中的第i个位置的元素的值 ListInsert(&amp;L,i,e): 插入操作。在表中的第i个位置上插入指定元素e ListDelete(&amp;L,i,&amp;e): 删除操作。删除表中第i个位置的元素，并用e返回删除元素的值 PrintList(L): 输出操作。按前后顺序输出线性表的所有元素值 Empty(L): 判空操作。若L为空表，则返回true，否则返回false DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间 线性表的顺序表示顺序表的定义线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第一个元素存储在线性表的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素。 假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为 12345#define MaxSize 50 //定义线性表的最大长度typedef struct { ElemType data[MaxSize]; //顺序表的元素 int length; //顺序表的当前长度}SqList; //顺序表的类型定义 特点 表中元素的逻辑顺序与其物理顺序相同 随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素 存储密度高，每个节点只存储数据元素 插入和删除操作需要移动大量元素 基本操作的实现 插入操作在顺序表L的第i个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将顺序表的第i个元素及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true1234567891011bool ListInsert(SqList &amp;L,int i,ElemType e) { if(i&lt;1||i&gt;L.length+1) //判断i的范围是否有效 return false; if(L.length&gt;=MaxSize) //当前存储空间已满，不能插入 return false; for(int j=L.length-1;j&gt;=i;j--) //将第i个元素及之后的元素后移 L.data[j]=L.data[j-1]; L.data[i-1]=e; //在位置i处放入e L.length++; //线性表长度加1 return true;} 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)最坏情况：在表头插入（即i=1），元素后移语句将执行n次，时间复杂度为O(n)平均情况：n/2次 因此线性表插入算法的平均时间复杂度为O(n) 删除操作删除顺序表L中第i个位置的元素，若成功则返回true，并将被删除的元素用引用变量e返回，否则返回false123456789bool ListDelete(SqList &amp;L,int i,Elemtype &amp;e) { if(i&lt;1||i&gt;L.length) //判断i的范围是否有效 return false; e=L.data[i-1]; //将被删除的元素赋值给e for(int j=i;j&lt;L.length;j++) //将第i个位置后的元素前移 L.data[j-1]=L.data[j]; L.length--; //线性表长度减1 return true;} 最好情况：删除表尾元素（i=n），无须移动元素，时间复杂度为O(1)最坏情况：删除表头元素（i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)平均情况：$\\frac{n-1}{2}$次 因此线性表删除算法的平均时间复杂度为O(n) 按值查找在顺序表L中查找第一个元素值等于e的元素，并返回其位序1234567int LocateElem(SqList L,ElemType e) { int i; for(i=0;i&lt;L.length;i++) if(L.data[i]==e) return i+1; //下标为i的元素值等于e，返回其位序i+1 return 0; //退出循环，说明查找失败} 最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)最坏情况：查找的元素在表尾（或不存在时），需要比较n次，时间复杂度为O(n)平均情况：假设$p_i$是查找的元素在第i个位置上的概率，则平均次数为$$\\sum^n_{i=1}p_i\\times i=\\sum^n_{i=1}\\frac{1}{n}\\times i=\\frac{1}{n}\\frac{n(n+1)}{2}=\\frac{n+1}{2}$$ 因此线性表查找算法的平均时间复杂度为O(n) 线性表的链式表示单链表的定义线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表节点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。 单链表中结点类型的描述如下： 1234typedef struct LNode { //定义单链表节点类型 ElemType data; //数据域 struct LNode *next; //指针域} LNode,*LinkList; 优点：不需要大量连续存储空间 缺点：附加指针域浪费存储空间 特点：非随机存取的存储结构，即查找某个特定的节点时，需要从表头开始遍历，依次查找 通常用头指针来表示一个单链表，如单链表L，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个节点之前附加一个节点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素节点，如图所示： 头结点和头指针的区分：不管带不带头结点，头指针始终指向链表的第一个节点，而头结点是带头结点的链表中的第一个节点，节点内通常不存储信息 引入头结点后，可以带来两个优点： 由于开始节点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一直，无须进行特殊处理 无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就得到了统一 单链表上基本操作的实现 采用头插法建立单链表每次将读入的新节点插入链表的表头，即头结点之后 1234567891011121314LinkList List_HeadInsert(LinkList &amp;L) { LNode *s;int x; L=(LinkList)malloc(sizeof(LNode)); //创建头结点 L-&gt;next=NULL; //初始为空链表 scanf(&quot;%d&quot;,&amp;x); //输入节点的值 while(x!=9999) { //输入9999表示结束 s=(LNode*)malloc(sizeof(LNode)); //创建新节点 s-&gt;data=x; s-&gt;next=L-&gt;next; L-&gt;next=s; //将新节点插入表中，L为头指针 scanf(&quot;%d&quot;,&amp;x); } return L;} 采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。每个节点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n) 采用尾插法建立单链表增加一个尾指针r，使其始终指向当前链表的尾结点 12345678910111213141516LinkList List_TailInsert(LinkList &amp;L) { //从表头到表尾正向建立单链表，每次均在表尾插入元素 int x; //设元素类型为整型 L=(LinkList)malloc(sizeof(LNode)); LNode *s,*r=L; //r为表尾指针 scanf(&quot;%d&quot;,&amp;x); //输入节点的值 while(x!=9999) { s=(LNode*)malloc(sizeof(LNode)); s-&gt;data=x; r-&gt;next=s; r=s; scanf(&quot;%d&quot;,&amp;x); } r-&gt;next=NULL; //尾结点指针置空 return L;} 因为附设了一个指向表尾节点的指针，故时间复杂度和头插法的相同 按序号查找节点值在单链表中从第一个节点出发，顺指针next域逐个往下搜索，直到找到第i个节点为止，否则返回最后一个节点指针域NULL 1234567891011121314LNode *GetElem(LinkList L,int i) { //本算法取出单链表L（带头结点）中第i个位置的节点指针 int j=1; //计数，初始为1 LNode *p=L-&gt;next; //头结点指针赋给p if(i==0) return L; //若i等于0，则返回头结点 if(i&lt;1) return NULL; //若i无效，则返回NULL while(p&amp;&amp;j&lt;i) { //从第1个节点开始找，查找到第i个节点 p=p-&gt;next; j++; } return p; //返回第i个节点的指针，如果i大于表长，p=NULL，直接返回p即可} 按序号查找操作的时间复杂度为O(n) 按值查找表节点从单链表的第一个节点开始，由前往后依次比较表中各节点数据的值，若某节点数据域的值等于给定值e，则返回该节点的指针；若整个单链表中没有这样的节点，则返回NULL 1234567LNode *LocateElem(LinkList L,ElemType e) { //本算法查找单链表L（带头结点）中数据域值等于e的结点指针，否则返回NULL LNode *p=L-&gt;next; while(p!=NULL&amp;&amp;p-&gt;data!=e) //从第1个结点开始查找data域为e的结点 p=p-&gt;next; return p; //找到后返回该结点指针，否则返回NULL} 插入结点操作插入结点操作将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点 代码片段如下 123p=GetElem(L,i-1); //查找插入位置的前驱结点s-&gt;next=p-&gt;next;p-&gt;next=s; 本算法主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若在给定的结点后面插入新结点，则时间复杂度仅为O(1) 删除结点操作删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。 假设结点p为找到的被删结点的前驱结点，为实现这一操作后的逻辑关系的变化，仅需修改p的指针域，即将p的指针域next指向q的下一结点。代码片段如下： 1234p=GetElem(L,i-1); //查找删除位置的前驱结点q=p-&gt;next; //令q指向被删除结点p-&gt;next=q-&gt;next; //将*q结点从链中“断开”free(q); //释放结点的存储空间 和插入算法一样，该算法的主要时间也耗费在查找操作上，时间复杂度为O(n) 求表长操作求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个节点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，知道访问到空节点位置。算法的时间复杂度为O(n) 双链表双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点 1234typedef struct DNode { //定义双链表结点类型 ElemType data; //数据域 struct DNode *prior,*next; //前驱和后继指针} DNode, *DLinklist; 双链表仅在单链表的结点中增加了一个指向其前驱的prior指针，因此在双链表中执行按值查找和按位查找的操作与在单链表中的相同。但双链表在插入和删除操作的实现上，与单链表有着较大的不同。这是因为“链”变化时也需要对prior指针做出修改 双链表的插入操作在双链表中p所指的结点之后插入结点*s，代码片段如下 1234s-&gt;next=p-&gt;next; //将结点*s插入到结点*p之后p-&gt;next-&gt;prior=s;s-&gt;prior=p;p-&gt;next=s; 上述代码的语句顺序不唯一，但也不是任意的。前两句必须在第四局之前，否则*p的后继指针就会丢掉，导致插入失败 双链表的删除操作删除双链表中节点p的后继结点q，代码片段如下 123p-&gt;next=q-&gt;next;q-&gt;next-&gt;prior=p;free(q); //释放结点空间 循环链表 循环单链表循环单链表和单链表的区别在于，表中最后一个节点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环，如图循环单链表中没有指针域为NULL的结点，因此它的判空条件不是头结点的指针是否为空，而是它是否等于头指针 循环双链表头结点的prior指针还要指向表尾结点，如图在循环双链表L中，某结点*p为尾结点时，p-&gt;next==L;当循环双链表为空表时，其头结点的prior域和next域都等于L 静态链表借助数组来描述线性表的链式存储结点，结点也有数据域和指针域，与前面的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间，如图静态链表结构类型的描述如下： 12345#define MaxSize 50 //静态链表的最大长度typedef struct { //静态链表结构类型的定义 ElemType data; //存储数据元素 int next; //下一个元素的数组下标} SLinkList[MaxSize]; 静态链表以next==-1来作为其结束的标志。总体来说，静态链表没有单链表使用起来方便吗，但在一些不支持指针的高级语言（如Basic）中，这是一种非常巧妙的设计方法 顺序表和链表的比较 存取方式顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素 逻辑结构与物理结构采用顺序存储时，逻辑上相邻的元素，其对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，其物理存储位置则不一定相邻，其对应的逻辑关系是通过指针链接来表示的 查找、插入和删除操作对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)；顺序表有序时，可采用这般查找，此时的时间复杂度为$O(\\log_2n)$对于按序号查找，顺序表时间复杂度仅为O(1)，而链表则为O(n)。但链表的插入和删除操作要比顺序表方便很多。 空间分配顺序存储在静态存储分配情形下，一旦存储空间装满就不能再加入新元素，因此需要预先分配足够大的存储空间。预先分配过大，可能导致浪费；预先分配过小，可能导致溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效 在实际中应该怎样选取存储结构 基于存储的考虑难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的 基于运算的考虑存顺序表中按序号访问的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表在顺序表中进行插入删除操作时需要移动较多的元素；在链表中进行插入删除操作时，虽然也要找插入位置，但操作主要是比较操作。从这个角度考虑显然后者优于前者 基于环境的考虑顺序表容易实现，任何高级语言中都有数组类型；链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素 总之两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）适合选择链式存储 第三章 栈和队列栈栈的基本概念 定义一种特殊的线性表，插入和删除在同一端，该端叫栈顶（top），另一端叫栈底（bottom）特点：后进先出（LIFO），故也称为后进先出的线性表 基操 InitStack(&amp;S): 初始化一个空栈S StackEmpty(S): 判断一个栈是否为空，若栈S为空则返回true，否则返回false Push(&amp;S,x): 进栈，若栈S未满，则将x加入使之成为新栈顶 Pop(&amp;S,x):出栈，若栈S非空，则弹出栈顶元素，并用x返回栈顶元素 GetTop(S,&amp;x): 读栈顶元素（不弹出） ClearStack(&amp;S): 销毁栈，并释放栈S所占用的存储空间（注意，符号“&amp;”是C++特有的，用来表示引用调用，采用C语言中的指针类型“*”也可以达到传址的目的 n个不同元素进栈，出栈元素不同排列的个数是$\\frac{1}{n+1}C^n_{2n}$ 栈的顺序存储结构 顺序栈的实现12345#define MaxSize 50 //定义栈中元素的最大个数typedef struct { Elemtype data[MaxSize]; //存放栈中元素 int top; //栈顶指针} SqStack; 顺序栈的基本运算 (1) 初始化 123void InitStack(SqStack &amp;S) { S.top=-1; //初始化栈顶指针} (2) 判栈空 123456bool StackEmpty(SqStack S) { if(S.top==-1) //栈空 return true; else //不空 return false;} (3) 进栈 123456bool Push(SqStack &amp;S,ElemType x) { if(S.top==MaxSize-1) //栈满，报错 return false; S.data[++S.top]=x; //指针先加1，再入栈 return true;} (4) 出栈 123456bool Pop(SqStack &amp;S,ElemType &amp;x) { if(S.top==-1) //栈空，报错 return false; x=S.data[S.top--]; //先出栈，指针再减1 return true;} (5) 读栈顶元素 123456bool GetTop(SqStack S,ElemType &amp;x) { if(S.top==-1) //栈空，报错 return false; x=data[S.top]; //x记录栈顶元素 return true;} 注意：这里栈顶指针指向的是栈顶元素，所以进栈时的操作是S.data[++S.top]=x,出栈时的操作是x=S.data[S.top–].若栈顶指针初始化为S.top=0，即栈顶指针指向栈顶元素的下一个位置，则会有变化 共享栈利用栈底位置相对不变的特性，可让两个顺序栈共享一个一位数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸 栈的链式存储结构采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满溢出的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead指向栈顶元素，如图 1234typedef struct Linknode { ElemType data; //数据域 struct Linknode *next; //指针域} *LiStack; //栈类型定义 栈的应用检查左右括号是否匹配扫描，碰见左括号入栈，碰见右括号就弹栈进行比对，若为空就报错结束时，如果栈不为空，则报错 后缀表达式求值扫描，碰见操作数就将它入栈，碰见运算符就弹两个操作数出栈计算后将结果入栈。结束时取出栈顶元素 中缀表达式转化为后缀表达式 如果读到的操作数就直接输出 如果读到的是运算符 当读到的运算符优先级大于栈顶元素优先级或者栈为空时，将该运算符入栈 当读到的是”)”时，不断弹出栈顶元素并输出直到栈顶元素为”(“，此时弹出”(“但不输出 当读到的运算符优先级小于栈顶元素优先级时，不断弹出栈顶元素并输出直到读到的运算符优先级大于栈顶元素，此时将读到的运算符入栈 将输入的字符序列扫描完毕后，如果栈内还有元素，就不断弹栈输出直到栈空为止 优先级如下表所示，isp是栈内优先（in stack priority)数，icp是栈外优先（in coming priority）数 操作符 # ( *, / +, - ) isp 0 1 5 3 6 icp 0 6 4 2 1 栈在递归中的应用递归解题思路：把规模较大的问题缩小到一目了然 递归包含 基本状态（出口） 普通状态（递归） 递归运算相当于在栈内运算 递归函数编写不好会导致栈溢出 递归运算每增加一个数时间增长一倍 优点：可读性强 缺点：冗余太多 用递归的条件 深度不能太深 可读性明显高 时间在同一数量级 队列定义一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。特点：**先进先出(FIFO)**，故又称先进先出的线性表 基操 InitQueue(&amp;Q): 初始化队列，构造一个空队列Q QueueEmpty(Q): 判队列空，若队列Q为空返回true，否则返回false EnQueue(&amp;Q,x): 入队，若队列Q未满，将x加入，使之成为新的队尾 DeQueue(&amp;Q,x): 出队，若队列Q非空，删除队首元素，并用x返回 GetHead(Q,&amp;x): 读队首元素，若队列Q非空，则将队首元素赋值给x 队列的顺序存储12345#define MaxSize 50 //定义队列中元素的最大个数typedef struct{ ElemType data[MaxSize]; //存放队列元素 int front, rear; //队首指针和队尾指针} SqQueue; 初始状态：Q.front==Q.rear==0 队空条件：Q.front==Q.rear 进队操作：队不满时，先送值到队尾元素，再将队尾指针加1 出队操作：队不空时，先取队首元素值，再将队首指针加1 队列的初始状态如上图所示，rear=MaxSize并不能作为队列满的条件。最后一张图中队列仅有一个元素，但仍满足该条件，这是一种“假溢出”。这个问题需要循环队列来解决 循环队列把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针Q.front=MaxSize-1后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现 初始时：Q.front=Q.rear=0 队首指针进1：Q.front=(Q.front+1)%MaxSize 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize 按照常规做法，队空和队满时都有Q.front==Q.rear 为了区分队空还是队满的的情况，有几种处理方式 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是一种较为普遍的做法，约定以“队首指针在队尾指针的下一位置作为队满的标志”，如图 队满条件：(Q.rear+1)%MaxSize==Q.front 队空条件：Q.front==Q.rear 队列中元素的个数：(Q.rear+MaxSize-Q.front)%MaxSize 类型中增设表示元素个数的数据成员size 队空条件：size==0 队满条件：size==MaxSize 这两种情况都有Q.front==Q.rear 以牺牲一个单元来判断队空队满的队列的操作代码 初始化123void InitQueue(SqQueue &amp;Q) { Q.rear=Q.front=0; //初始化队首指针和队尾指针} 判队空123456bool isEmpty(SqQueue Q){ if(Q.rear==Q.front) //队空条件 return true; else return false;} 入队1234567bool EnQueue(SqQueue &amp;Q, ElemType x){ if((Q.rear+1)%MaxSize==Q.front) return false; //队满 Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; //队尾指针加1取模 return true;} 出队1234567bool DeQueue(SqQueue &amp;Q,ElemType &amp;x){ if(Q.rear==Q.front) return false; x=Q.data[Q.front]; Q.front=(Q.front+1)%MaxSize; return true;} 队列的链式存储队列的链式存储称为链队列，它实际上是一个同时带有队首指针和队尾指针的单链表。头指针指向队首节点，尾指针指向队尾节点，即单链表的最后一个结点（与顺序存储不同，顺序存储的尾指针指向的是最后一个结点的下标加1） 带头结点的链式队列： 1234567typedef struct { //链式队列结点 ElemType data; struct LinkNode *next;} LinkNode;typedef struct { //链式队列 LinkNode *front,*rear; //队列的队首指针和队尾指针} LinkQueue; 当Q.front==null且Q.rear==null时，链式队列为空 链式队列的基操 初始化1234void InitQueue(LinkQueue &amp;Q) { Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode)); //建立头结点 Q.front-&gt;next=NULL; //初始为空} 判队空123456bool IsEmpty(LinkQueue Q) { if(Q.front==Q.rear) return true; else return false;} 入队1234567void EnQueue(LinkQueue &amp;Q,ElemType x) { LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode)); s-&gt;data=x; s-&gt;next=NULL; //创建新结点 Q.rear-&gt;next=s; Q.rear=s; //插入到队尾} 出队1234567891011bool DeQueue(LinkQueue &amp;Q,ElemType &amp;x) { if(Q.front==Q.rear) return false; //空队 LinkNode *p=Q.front-&gt;next; x=p-&gt;data; Q.front-&gt;next=p-&gt;next; if(Q.rear==p) Q.rear=Q.front; //若原队列中只有一个结点，删除后变空 free(p); return true;} 双端队列双端队列是指允许两端对可以进行入队和出队操作的队列。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队 输出受限的双端队列：允许在一段进行插入和删除，但在另一端只允许插入 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除。若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈 队列的应用队列在层次遍历（广度优先遍历）中的应用层次遍历二叉树的过程 根节点入队 若队空（所有节点都已处理完毕），则结束遍历；否则重复3.操作 队列中第一个节点出队，并访问。若其有左子，则将左子入队；若其有右子，则将右子入队，返回2.12345678graph binaryTree { node[shape=circle]; A--B,C B--D C--E,F D--G E--H,I} 层次遍历二叉树的过程 序 说明 队内 队外 1 A入 A 2 A出，BC入 BC A 3 B出，D入 CD AB 4 C出，EF入 DEF ABC 5 D出，G入 EFG ABCD 6 E出，HI入 FGHI ABCDE 7 F出 GHI ABCDEF 8 GHI出 ABCDEFGHI 队列在计算机系统中的应用 解决主机与外部设备之间速度不匹配的问题 以主机和打印机之间速度不匹配的问题为例。主机输出数据给打印机打印，输出数据的速度比打印数据的速度要快得多，由于速度不匹配，若直接把输出的数据送给打印机打印显然是不行的。解决的方法是设置一个打印数据缓冲区，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他的事情。打印机就从缓冲区中按照先进先出的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求后再向缓冲区写入打印数据。这样做既保证了打印数据的正确，又使主机提高了效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列 解决由多用户引起的资源竞争问题 在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又能使CPU正常运行 第四章 树与二叉树树的基本概念树的定义树是n(n&gt;=0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足： 有且仅有一个特定的称为根的结点 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合T1,T2,…,Tm,其中每个集合本身又是一棵树，并且称为根节点的子树 树的定义是递归的特点： 树的根节点没有前驱结点，除根节点外的所有节点有且只有一个前驱结点 树中所有节点可以有零个或多个后继结点 树中某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n-1条边 树的基本术语 根结点 兄弟结点 内部结点：有子结点 外部结点（叶子结点）：没有子结点 祖先结点：父结点、爷爷结点、曾爷爷结点…… 子孙结点 结点的深度（Depth）：祖先结点的个数 树的高度（Height）：深度最大值（只有根结点为0，空树为-1） 结点的度（Degree）：子结点个数 树的度：结点的度的最大值 子树（Subtree） 森林：m棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根节点删去就成了森林 树的性质 树的结点数等于所有结点的度数加1 度为m的树中第i层上至多有$m^{i-1}$个结点（i&gt;=1） 高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点 具有n个结点的m叉树的最小高度为$[\\log_m(n(m-1)+1)]$ 二叉树的概念二叉树的定义及其主要特性1. 二叉树的定义特点：每个节点最多有两个子结点（可以只有一个）子结点有序，分别称左子结点和右子结点，其次序不能任意颠倒 二叉树是有序树，即使树中节点只有一棵子树，也要区分它是左子树还是右子树 二叉树与度为2的有序树的区别： 度为2的树至少有3个结点，而二叉树可以为空 度为2的有序树的孩子结点的左右次序是相对于另一孩子结点而言的，若某个结点只有一个孩子结点，则这个孩子结点就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的 2. 几个特殊的二叉树 满二叉树 树中每一个层的结点数都达到最大值。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2 按层从上往下标号，同一层从左往右标 123456graph tree{ node[shape=circle] 1--2,3 2--4,5 3--6,7} 结点i的父结点编号是i/2结点i左子结点编号是2i 右子结点编号是2i+1满二叉树用数组存最合适 完全二叉树最后一层从右往左可以缺结点编号和满二叉树对应 12345graph tree{ node[shape=circle] 1--2,3 2--4,5} 二叉排序树性质：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字。左子树和右子树又各是一棵二叉排序树 平衡二叉树树上任一结点的左子树和右子树的深度之差不超过1 3. 二叉树的性质 非空二叉树上的叶子结点数等于度为2的结点数加1，即n0=n2+1 非空二叉树上第k层上至多有$2^{k-1}$个结点（k&gt;=1） 二叉树的存储结构1. 顺序存储结构一般完全二叉树和满二叉树使用 将完全二叉树上编号为i的结点元素存储在某个数组下标在i-1的分量中，然后通过一些方法确定结点在逻辑上的父子和兄弟关系 对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照 满二叉树顺序存储: 普通二叉树顺序存储： 2. 链式存储结构用一个链表来存储一棵二叉树，二叉树中的每个结点用链表的一个链结点来存储。在二叉树中，结点结构至少包含3个域：数据域data、左指针域lchild、右指针域rchild 1234typedef struct BiTNode { ElemType data; //数据域 struct BiTNode *lchild,*rchild; //左右孩子指针} BiTNode,*BiTree; 在含有n个结点的二叉链表中，含有n+1个空链域 二叉树的遍历和线索二叉树遍历1. 先序遍历操作过程：若二叉树为空，则什么也不做；否则： 访问根结点 先序遍历左子树 先序遍历后子树1234567void PreOrder(BiTree T) { if(T!=null){ visit(T); //访问根结点 PreOrder(T-&gt;lchild); //递归遍历左子树 PreOrder(T-&gt;rchild); //递归遍历右子树 }} 2. 中序遍历操作过程:若二叉树为空，则什么也不做；否则： 中序遍历左子树 访问根结点 中序遍历右子树1234567void InOrder(BiTree T) { if(T!=null){ InOrder(T-&gt;lchild); //递归遍历左子树 visit(T); //访问根结点 InOrder(T-&gt;rchild); //递归遍历右子树 }} 3. 后序遍历操作过程：若二叉树为空，则什么也不做；否则： 后序遍历左子树 后序遍历右子树 访问根结点1234567void PostOrder(BiTree T) { if(T!=null){ PostOrder(T-&gt;lchild); //递归遍历左子树 PostOrder(T-&gt;rchild); //递归遍历右子树 visit(T); //访问根结点 }} 4. 递归算法和非递归算法的转换借助栈，可以将二叉树的递归遍历算法转换为非递归遍历算法。 以中序遍历为例：先扫描（并非访问）根结点的所有左结点并将它们一一进栈，然后出栈一个节点*p（显然结点*p没有左子结点或左子结点均已访问过），访问它。然后扫描该结点的右子结点，将其进栈，再扫描该右子结点的所有左结点并一一进栈，如此继续，知道栈空为止 123456789101112131415void InOrder2(BiTree T) { InitStack(S); BiTree p=T; //初始化栈；p是遍历指针 while(p||!IsEmpty(S)) { //栈不空或p不为null时遍历 if(p) { //根指针进栈，遍历左子树 Push(S,p); //每遇到非空二叉树先向左走 p=p-&gt;lchild; } else { //根指针退栈，访问根结点，遍历右子树 Pop(S,p); visit(p); //退栈，访问根结点 p=p-&gt;rchild; //再向右子树走 } }} 5. 层次遍历借助一个队列。先将二叉树根结点入队，然后入队，访问该结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。然后出队，对出队结点访问，如此反复，直到队列为空 12345678910111213void LevelOrder(BiTree T) { InitQueue(Q); //初始化辅助队列 BiTree p; EnQueue(Q,T); //将根结点入队 while(!IsEmpty(Q)) { //队列不空循环 DeQueue(Q,p); //队首元素出队 visit(p); //访问当前p所指向结点 if(p-&gt;lchild!=null) EnQueue(Q,p-&gt;lchild); //左子树不空，则左子树入队列 if(p-&gt;rchild!=null) EnQueue(Q,p-&gt;rchild); //右子树不空，则右子树入队列 }} 6. 由遍历序列构造二叉树由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列 同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树 例如，求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树 1234graph t1{ node[shape=circle]; A--BC,DEFGHI} 12345678graph t2{ node[shape=circle]; 1[shape=plain,label=&quot; &quot;] A--B,D; B--1 [style=dotted]; B--C; D--E,FGHI} 123456789101112graph t3{ node[shape=circle]; 1[shape=plain,label=&quot; &quot;] 2[shape=plain,label=&quot; &quot;] A--B,D; B--1[style=dotted]; B--C; D--E,F; F--G,I; G--2[style=dotted]; G--H;} 线索二叉树1. 线索二叉树的基本概念普通二叉树中存在大量的空指针（n个结点的二叉树有n+1个空指针），若利用这些空指针存放指向其直接前驱或后继的指针，则可以更方便地运用某些二叉树操作算法。引入线索二叉树是为了加快查找结点前驱和后继的速度。 线索二叉树的结点结构： 12345digraph g { node[shape=record,height=.1]; //定义了下面的node样式 node0[label=&quot;&lt;f0&gt;ltag |&lt;f1&gt; lchild|&lt;f2&gt; data|&lt;f3&gt;rchild |&lt;f4&gt;rtag&quot;]; } ltag=0：lchild域指示结点的左子结点 ltag=1：lchild域指示结点的前驱 rtag=0：rchild域指示结点的右子结点 rtag=1：rchild域指示结点的后继 12345typedef strcut ThreadNode { ElemType data; /数据元素 struct ThreadNode *lchild,*rchild; //左右孩子指针 int ltag,rtag;} ThreadNode,*ThreadTree; 2. 线索二叉树的构造对二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索 3. 线索二叉树的遍历非递归遍历不再需要借助栈，因为它的结点中隐含了线索二叉树的前驱和后继信息 求中序线索二叉树中中序序列下的第一个结点：12345ThreadNode *Firstnode(ThreadNode *p) { while(p-&gt;ltag==0) p=p-&gt;lchild; //最左下结点（不一定是叶子结点） return p;} 求中序线索二叉树中结点p在中序序列下的后继结点：123456ThreadNode *Nextnode(ThreadNode *p) { if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild;} 利用上面两个算法，可以写出不含头结点的中序线索二叉树的中序遍历的算法1234void Inorder(ThreadNode *T) { for(ThreadNode *p=Firstnode(T);p!=null;p=Nextnode(p)) visit(p);} 树、森林树的存储结构1. 双亲表示法一组连续空间来存储每个节点，同时再每个节点中增设一个伪指针，指示其双亲节点在数组中的位置。根结点下标为0，其伪指针域为-1 123456graph ptree{ node[shape=circle]; R--A,B,C; A--D,E; C--F--G,H,K;} 下标 data parent 0 R -1 1 A 0 2 B 0 3 C 0 4 D 1 5 E 1 6 F 3 7 G 6 8 H 6 9 K 6 123456789#define MAX_TREE_SIZE 100 //树中最多结点数typedef struct { //树的结点定义 ElemType data; //数据元素 int parent; //双亲位置域} PTNode;typedef struct { //树的类型定义 PTNode nodes[MAX_TREE_SIZE]; //双亲表示 int n; //结点数} PTree; 该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构 2. 孩子表示法将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表 3. 孩子兄弟表示法孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿次域可以找到结点的所有兄弟结点） 1234typedef struct CSNode{ ElemType data; Struct CSNode *firstchild,*nextsibling; //第一个孩子和右兄弟指针} CSNode,*CSTree; 这种表示法比较灵活，最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便 树和森林的遍历 先根遍历若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树。其访问顺序与这棵树相应二叉树的先序遍历顺序相同 后根遍历若树非空，则按从左到右的顺序遍历根结点的每棵子树，之后再访问根结点。其访问顺序与这棵树相应二叉树的中序遍历顺序相同 森林的两种遍历方法 先序遍历森林。若森林非空，则按如下规则进行遍历： 访问森林中第一棵树的根结点 先序遍历第一棵树中根结点的子树森林 先序遍历除去第一棵树之后剩余的树构成的森林 中序遍历森林。若森林为非空，则按如下规则进行遍历： 中序遍历森林中第一棵树的根结点的子树森林 访问第一棵树的根结点 中序遍历除去第一棵树之后剩余的树构成的森林 树、森林、二叉树遍历对应的关系 树 森林 二叉树 先根遍历 先序遍历 先序遍历 后根遍历 中序遍历 中序遍历 树的应用——并查集并查集是一种简单的集合表示，它支持以下3种操作： Union(S, Root1, Root2): 把集合S中的子集合Root2并入子集合Root1.要求Root1和Root2互不相交，否则不执行合并 Find(S,x): 查找集合S中单元素x所在的子集合，并返回该子集合的名字 Initial(S): 将集合S中的每个元素都初始化为只有一个单元素的子集合 通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示 将root2并入到root1中查找x所属于的根节点（或者说是x所属于的集合），就可以一直找array[x]，直到array[x]小于0，则证明找到了根（所在集合） 结构定义： 12#define SIZE 100int UFSets[SIZE]; //集合元素数组（双亲指针数组） 初始化操作： 1234void Initial(int S[]){ for(int i=0;i&lt;size;i++) //每个自成单元素集合 S[i]=-1;} Find操作（找到包含元素x的树的根） 12345int Find(int S[],int x){ while(S[x]&gt;=0) //循环寻找x的根 x=S[x]; return x; //根的S[]小于0} Union操作（函数求两个不相交子集合的并集） 1234void Union(int S[],int Root1,int Root2) { //要求Root1和Root2是不同的，且表示子集合的名字 S[Root2]=Root1; //将根Root2连接到Root1下面} 树与二叉树的应用二叉排序树1. 二叉排序树的定义二叉排序树（BST），也称二叉查找树。二叉排序树或者是一棵空树，或者是一棵具有下列特性的非空二叉树 若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字值 若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字值 左右子树本身也分别是一棵二叉排序树 对二叉排序树进行中序遍历，可以得到一个递增的有序序列 2. 二叉排序树的查找若树非空，将给定值与根结点的关键字比较，若相等，则查找成功；若不等，则当根结点的关键字值大于给定关键字值时，在根结点的左子树中查找，否则在根结点的右子树中查找 123456789101112BSTNode *BST_Search(BiTree T, ElemType key, BSTNode *&amp;p) { //查找函数返回指向关键字值为key的结点指针，若不存在，返回null p=null; //p指向被查找结点的双亲，用于插入和删除操作中 while(T!=null&amp;&amp;key!=T-&gt;data) { p=T; if(key&lt;T-&gt;data) T=T-&gt;lchild; else T=T-&gt;rchild; } return T;} 3. 二叉排序树的插入若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点关键字，则插入左子树，若关键字k大于根结点关键字，则插入右子树 1234567891011121314int BST_Insert(BiTree &amp;T, KeyType k) { if(T==null) { //原数为空，新插入的记录为根结点 T=(BiTree)malloc(sizeof(BSTNode)); T-&gt;key=k; T-&gt;lchild=T-&gt;rchild=null; return 1; //返回1，表示成功 } else if(k==T-&gt;key) //树中存在相同关键字的结点 return 0; else if(k&lt;T-&gt;key) //插入T的左子树 return BST_Insert(T-&gt;lchild,k); else //插入T的右子树 return BST_Insert(T-&gt;rchild,k);} 4. 二叉排序树的构造 12345678void Creat_BST(BiTree &amp;T, KeyType str[], int n) { T=null; //初始时bt为空树 int i=0; while(i&lt;n) { //依次插入每个元素 BST_Insert(T,str[i]); i++; }} 5. 二叉排序树的删除三种情况： 若被删除结点z是叶子结点，则直接删除，不会破坏二叉排序树的性质 若结点z只有一颗左子树或右子树，则让z的子树称为z父结点的子树，替代z的位置 若结点z有左右两颗子树，可以分为以下两步第一步：查找删除结点右子树中最小的那个值，也就是右子树中位于最左方的那个结点。然后将这个结点的值的父节点记录下来。并且将该节点的值赋给我们要删除的结点。也就是覆盖。第二步：然后将右子树中最小的那个结点进行删除，该节点肯定符合上述三种情况的某一种情况，所以可以使用上述的方法进行删除。 6. 二叉排序树的查找效率分析对于高度为h的二叉排序树，其插入和删除操作的运行时间都是O(h)。但在最坏的情况下，即构造二叉排序树的输入序列是有序的，则会行程一个倾斜的单支树，此时二叉排序树的性能显著变坏，输的高度也增加为元素个数n。 二叉排序树查找算法的平均查找长度，主要取决于树的高度。若二叉排序树是一个只有右（左）孩子的单支树，则其平均查找长度和单链表相同，为O(n)。若二叉排序树的左右子树的高度之差的绝对值不超过1，则这样的二叉排序树称为平衡二叉树。它的平均查找长度达到$O(\\log_2 n)$ 从查找过程看，二叉排序树与二分查找类似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树 就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为$O(\\log_2n)$。二分查找的对象是有序顺序表，若有插入和删除结点的操作，所花的代价是O(n)。当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构 平衡二叉树1. 平衡二叉树的定义任意结点的左右子树高度差的绝对值不超过1，这样的二叉树称为平衡二叉树，简称平衡树（AVL）。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1,0或12. 平衡二叉树的插入二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡 平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。一般可归纳为下列4种情况 LL平衡旋转（右单旋转）。在结点A的左孩子（L）的左子树（L）上插入了新结点。此时将A的左孩子向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树 RR平衡旋转（左单旋转）。基本上和LL一样，将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树 LR平衡旋转（先左后右双旋转）。在A的左孩子的右子树上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置 RL平衡旋转（先右后左双旋转）。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置 3. 平衡二叉树的查找过程与二叉排序树相同。平均查找长度为$O(\\log_2n)$ 哈夫曼树和哈夫曼编码哈夫曼树特殊类型二叉树，高效存储字符，基于使用频率 术语 路径 path 路径长度 path length 结点路径长度 二叉树路径长度 结点的权重 带权路径长度（结点） 二叉树带权路径长度 定义在许多实际应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树根结点到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶子结点的带权路径长度之和称为该树的带权路径长度，记为$$W!P!L=\\sum^n_{i=1}w_il_i$$其中，$w_i$是第i个叶子结点所带的权值，$l_i$是该叶子结点到根结点的路径长度 在含有n个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树 哈夫曼树的构造给定n个结点 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置位左右子树上根结点的权值之和 从F中删除选出的两棵树，同时将新得到的树加入F中 重复步骤2和3，直至F中只剩下一棵树为止 例子： 1234graph nodes{ node[shape=circle]; 5,15,40,30,10;} 1234567891011graph huffmanTree{ node[shape=circle]; 301[label=&quot;30&quot;]; 302[label=&quot;30&quot;]; 151[label=&quot;15&quot;]; 152[label=&quot;15&quot;]; 100--40,60; 60--301,302; 301--151,152; 151--5,10;} 哈夫曼树不唯一 哈夫曼编码 Huffman Code对于待处理的一个字符串序列，若对每个字符用同样长度的二进制位表示，则称这种编码方式为固定长度编码。若允许对不同字符用不等长的二进制位表示，则这种方式成为可变长度编码。可变长度编码可以对频率高的字符赋予短编码，节省空间，但可能有一个编码是另一个编码的前缀，产生二义性。 若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。 可以利用哈夫曼树得到前缀编码，称为哈弗曼编码。将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。所有字符结点都出现在叶子结点中。可将字符的编码解释为从根到该字符的路径上边标记的序列，其中边标记为0表示“转向左孩子”，边标记为1表示“转向右孩子” 左右结点的顺序是任意的，构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度相同且为最优 第五章 图图的基本概念图的定义图G由顶点集V和边集E组成，记为G=(V,E) $V={v_1,v_2,…,v_n}$，则用|V|表示图G中顶点的个数，也称图G的阶 $E={(u,v)|u\\in V, v\\in V}$,用|E|表示图G中边的条数u,v有序则E称为有向边，记作&lt;u,v&gt;u,v无序则E称为无向边，记作(u,v) 以下是图的一些基本术语 1. 有向图E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记作&lt;v,w&gt;，v称为弧尾，w称为弧头。&lt;v,w&gt;称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v 2. 无向图E是无向边（简称边）的有限集合时，则图G为有向图。边是顶点的无序对，记为(v,w)或(w,v)。可以说顶点w和顶点v互为临界点。边&lt;v,w&gt;依附于顶点w和v，或者说边(v,w)和顶点v,w相关联 3. 简单图满足 不存在重复边 不存在顶点到自身的边 4. 多重图不是简单图的就是多重图 5. 完全图（也称简单完全图）任意两个顶点间都有边 无向图：n(n-1)/2条边 有向图：n(n-1)条边 6. 子图设有两个图G=(V,E)和G’=(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’是G的子图。若V(G’)=V(G)，则称其为G的生成子图 7. 连通、连通图和连通分量 连通：在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的 连通图：任意两个顶点间有路径可达的无向图 连通分量：极大连通子图（不能是图中某个连通部分的子图）。任何连通图的连通分量都只有一个，即使是其本身；非连通的无向图有多个连通分量例：图中连通分量有三个，分别为ALMJBFC，DE，GIKH。而像ACF这样的连通子图则不能称为连通分量 极大连通子图：包含连通子图中所有的边极小连通子图：只有连通图有极小连通子图，是保持图连通，又要使边数最小的子图。连通图顶点集确定的生成树是该连通图的极小连通子图，不唯一 极大连通子图是讨论连通分量的,极小连通子图是讨论生成树的 8. 强连通图、强连通分量 强连通图：任意两个顶点间有路径可达的有向图 强连通分量：极大强连通子图 9. 生成树、生成森林 生成树：包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树的边数为n-1。对生成树而言，若砍去一条边，则会变成非连通图，若加上一条边则会形成一个回路 10. 顶点的度、入度和出度对于无向图，顶点v的度是指依附于该顶点的边的条数，记为TD(v) 对于有向图，入度是指到达的边的条数，出度是指发出的边的条数，度=入度+出度 11. 边的权和网在一个图中，每条边都可以标上具有某种含义的数值，该数值称为改边的权值。这种边上带有权值的图称为带权图，也称网 12. 稠密图、稀疏图边数很少的图称为稀疏图，反之称为稠密图。这是模糊的概念，往往是相对而言的。一般当|E|&lt;|V|log|V|时，可以视为稀疏图 13. 路径、路径长度和回路 路径：顶点的序列 长度：经过的边的条数 加权长度：边的权值之和 自环：开始和结束同一个顶点的边 回路（环）：起始顶点和结束顶点相同的路径 若一个图有n个顶点，并且有大于n-1条边，则该图一定有环 14. 简单路径、简单回路 简单路径：在路径序列中，顶点不重复出现的路径 简单回路：除起始顶点和结束顶点外，其余顶点不重复出现的回路 15. 距离从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷 16. 有向树一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树 图的存储及基本操作邻接矩阵法用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵 无权图的邻接矩阵：相邻两点有边记为1，无边记为0，对角线也为0带权图的邻接矩阵：相邻两点有边记为该边的权值，无边记为无穷大，对角线记为0（不同版本的教材有出入，有些也记为无穷。但对于实际应用（如求最短路径算法）来说，存0更为合理） 代码定义12345678#define MaxVertexNum 100 //顶点数目的最大值typedef char VertexType; //顶点的数据类型typedef int EdgeType; //带权图中边上权值的数据类型typedef struct { VertexType Vex[MaxVertexNum]; //顶点表 EdgeType Edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表 int vexnum,arcnum; //图的当前顶点数和弧数}MGraph; 注意： 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略） 当邻接矩阵中的元素仅表示响应的边是否存在时，EdgeType可定义为值为0和1的枚举类型 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储 邻接矩阵表示法的空间复杂度为$O(n^2)$，其中n为图的顶点数|V| 邻接矩阵有以下特点： 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素 对于无向图，邻接矩阵的第i行（或第i列）非零元素的个数正好是第i个顶点的度 对于有向图，邻接矩阵的第i行非零元素的个数是第i个顶点的出度，第i列非零元素的个数是第i个顶点的入度 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是要确定图中有多少条边，则必须按行按列对每个元素进行检测，开销很大 稠密图适合使用邻接矩阵存储 邻接表法当一个图为稀疏图时，使用邻接矩阵存储要浪费大量的存储空间 邻接表结合了顺序存储和链式存储，把顶点存入数组，依附于该顶点的边存入链表。类似于树的孩子表示法 对图G中每个顶点vi建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边（对于有向图是以顶点vi为尾的弧），这个单链表称为顶点vi的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表）。所以在邻接表中存在两种结点：顶点表结点和边表结点，如图,左为顶点表结点，右为边表结点 邻接表中边的顺序不重要 1234567891011121314#define MaxVertexNum 100 //图中顶点数目的最大值typedef struct ArcNode { //边表结点 int adjvex; //该弧所指向的顶点的位置 struct ArcNode *next; //指向下一条弧的指针 //InfoType info; //带权图的边权值}ArcNode;typedef struct VNode { //顶点表结点 VertexType data; //顶点信息 ArcNode *first; //指向第一条依附该结点的弧的指针}VNode,AdjList[MaxVertexNum];typedef struct { AdjList vertices; //邻接表 int vexnum,arcnum; //图的顶点数和弧数}ALGraph; //ALGraph是以邻接表存储的图的类型 邻接表有以下特点： 若G为无向图，则所需的存储空间为O(|V|+2|E|)；若G为有向图，则所需的存储空间为O(|V|+|E|)。前者的倍数2是由于无向图中，每条边在邻接表中出现了两次 对于稀疏图，采用邻接表表示将极大节省存储空间 在邻接表中，给定一顶点，能很容易找出所有它的邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n).但是，若要确定给定的两个顶点之间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要遍历边表查找，效率较低 在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表是类似的 图的邻接表并不唯一，因为边表中结点的顺序可以变 十字链表十字链表是有向图的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个点，对应于每个顶点也有一个结点。这些结点的结构如下图所示： 弧结点中：尾域（tailvex）和头域（headvex）分别指示弧尾和弧头这两个结点在图中的位置；链域hlink指向弧头相同的下一条弧；链域tlink指向弧尾相同的下一条弧；info域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上 顶点结点中：info（data）域存放顶点相关的数据信息，如顶点名称；firstin和firstout两个域分别指向以该顶点为弧头或弧尾的第一个弧结点 下图为有向图的十字链表表示法。注意，顶点结点之间是顺序存储的 编程语言定义如下： 1234567891011121314#define MaxVertexNum 100 //图中顶点数目的最大值typedef struct ArcNode { //边表结点 int tailvex, headvex; //该弧的头尾结点 struct AcrNode *hlink, *tlink; //分别指向弧头相同和弧尾相同的结点 //InfoType info; //相关信息指针} ArcNode;typedef struct VNode { //顶点表结点 VertexType data; //顶点信息 ArcNode *firstin, *firstout; //指向第一条入弧和出弧} VNode;typedef struct { VNode xlist[MaxVertexNum]; //邻接表 int vexnum,arcnum; //图的顶点数和弧数} GLGraph; //GLGraph是以十字邻接存储的图类型 在十字链表中，既容易找到vi为尾的弧，又容易找到vi为头的弧，因而容易求得顶点的出度和入度。 图的十字链表表示不是唯一的，但一个十字链表表示确定一个图 邻接多重表邻接多重表是无向图的另一种链式存储结构 在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低 与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示 mark用于标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域 每个顶点也用一个结点表示，它由如下所示的两个域组成 其中，data(vertex)域存储该顶点的相关信息，firstedge域指示第一条依附于该顶点的边 在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中 如图为无向图的邻接多重表表示。注意，每条边只有一个结点 {engine12345graph l{ V1--V2,V4; V2--V3,V5; V5--V3--V4;} 编程语言定义如下： 123456789101112131415#define MaxVertexNum 100 //图中顶点数目的最大值typedef struct ArcNode { //边表结点 bool mark; //访问标记 int ivex, jvex; //分别指向该弧的两个结点 struct ArcNode *ilink, *jlink; //分别指向两个顶点的下一条边 //InfoType info; //相关信息指针} ArcNode;typedef struct VNode { //顶点表结点 VertexType data; //顶点信息 ArcNode *firstedge; //指向第一条依附于该顶点的边} VNode;typedef struct { VNode adjmulist[MaxVertexNum]; //邻接表 int vexnum, arcnum; //图的顶点数和弧数} AMLGraph; //AMLGraph是以邻接多重表存储的图类型 图的基操独立于图的存储结构。对于不同的存储方式，操作算法的具体实现会有不同的性能 图的基本操作主要包括 Adjacent(G,x,y): 判断图G是否存在边&lt;x,y&gt;或(x,y) Neighbors(G,x): 列出图G中与结点邻接的边 InsertVertex(G,x): 在图G中插入顶点x DeleteVertex(G,x): 在图G中删除顶点x AddEdge(G,x,y): 若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向G中添加该边 RemoveEdge(G,x,y): 若无向边(x,y)或有向边&lt;x,y&gt;存在，则从图G中删除该边 FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1 NextNeighbor(G,x,y): 假设图中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1 GetEdgeValue(G,x,y): 获取图G中边(x,y)或&lt;x,y&gt;对应的权值 SetEdgeValue(G,x,y,v): 设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v 图的遍历广度优先搜索类似于二叉树的层次遍历 没有往回退的情况，因此不是一个递归的算法。 需要借助一个辅助队列，以记忆正在访问的顶点的下一层顶点 伪代码如下 1234567891011121314151617181920212223242526bool visited[MAX_VERTEX_NUM]; //访问标记数组void BFSTraverse(Graph G) { //对图G进行广度优先遍历，设访问数为visit() for(i=0;i&lt;G.vexnum;++i) //访问标记数组初始化 visited[i]=FALSE; InitQueue(Q); //初始化辅助队列Q for(i=0;i&lt;G.vexnum;++i) //从0号顶点开始遍历 if(!visited[i]) //对每个连通分量调用一次BFS BFS(G,i); //v_i_未访问过，从v_i_开始BFS}void BFS(Graph G,int v) { //从顶点v触发，广度优先遍历图G，算法借助一个辅助队列Q visit(v); //访问初始顶点v visited[v]=TRUE; //对v做已访问标记 Enqueue(Q,v); //顶点v入队列 while(!isEmpty(Q)) { DeQueue(Q,v); //顶点v出队列 for(w=FirstNeighnor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) { //检测v所有邻接点 if(!visited[w]) { //w为v的尚未访问的邻接顶点 visit[w]; //访问顶点w visited[w]=TRUE; //对w做已访问标记 EnQueue(Q,w); //顶点w入队列 } } }} 深度优先搜索类似于树的先序遍历 123456789101112131415161718bool visited[MAX_VERTEX_NUM]; //访问标记数组void DFSTraverse(Graph G) { //对图G进行深度优先遍历，访问函数为visit() for(v=0;v&lt;G.vexnum;++v) visited[v]=FALSE; //初始化已访问标记数据 for(v=0;v&lt;G.vexnum;++v) //本代码中是从v=0开始遍历 if(!visited[v]) DFS(G,v);}void DFS(Graph G,int v){ //从顶点v出发，采用递归思想，深度优先遍历图G visit(v); //访问顶点v visited[v]=TRUE; //设已访问标记 for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w]){ //w为u的尚未访问的邻接顶点 DFS(G,w); } } 注意：对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的 图的遍历与图的连通性图的遍历算法可以用来判断图的连通性 无向图如果连通，则从任一结点出发，仅需一次遍历就能访问图中所有顶点；无向图如果不连通，一次遍历只能访问到该结点所在的连通分量。对于有向图来说，如果从初始点到图中每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点 故在BFSTraverse或DFSTraverse中添加了第二个for循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用BFS(G,i)或DFS(G,i)的次数等于该图的连通分量数。有向图情况不同，非强连通分量调用一次BFS(G,i)或DFS(G,i)甚至无法访问到该连通分量的所有顶点 图的应用最小生成树连通图的顶点集确定的生成树是图的极小连通子图，它包含图中所有顶点，含有尽可能少的边。如果砍去它的一条边，则会使生成树变成非连通图；若增加一条边，就会形成一条回路 对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权（所有边权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的那课生成树，则T称为G的最小生成树 性质： 最小生成树不唯一。当图G中的各边权值互不相等是，G的最小生成树唯一；若G的边数比顶点数少1，则G的最小生成树为它本身 最小生成树的边的权值之和唯一 Kruskal算法每次在边集中找不会形成环的最小的边，添加到生成树，直到生成树全部连通 适用于求解边稀疏而顶点较多的图 Prim算法类似于Dijkstra算法 假定V={1,2,…,n}，以集合U={1}开始，每次添加一个顶点 找当前最短一条边(u,v) u属于U v属于V-U 适用于求解边稠密的图 最短路径Dijkstra算法非负权重 单点源头 贪心策略 核心思想：每次得到的最短的暂定最短路径对应的点被添加进已知 一个集合S，用于记录已求得的最短路径的顶点，用一个数组s[]来实现，初始化为0，s[vi]=1时表示将顶点$v_i$放入S，初始时把源点$v_0$放入S 两个辅助数组 dist[]: 记录从源点$v_0$到其他各顶点的最短路径长度，dist[i]的初值为arcs[v0][i] path[]: path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点$v_0$到顶点$v_i$的最短路径 步骤 初始化S&lt;–{$v_0$}dist[j]&lt;–edge[0][j] 找最短路径dist[j]&lt;–min{dist[i]}S&lt;–S并{k} 更新对每一个$i\\in V-S$dist[i]&lt;–min{dist[i],dist[k]+edge[k][i]} 如果使得S=V，返回。否则重回第一步 算法复杂度为$O(|V|^2)$ Floyd算法权值均大于0的有向图，对每对顶点$v_i\\neq v_j$都求出最短路径和最短路径长度 基本思想：递推产生一个n阶方阵序列$A^{(-1)},A{(0)},…,A^{(n-1)}$，其中$A^{(k)}[i][j]$表示从顶点$v_i$到$v_j$的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路长度；若它们之间不存在有向边，则以$\\infty$作为它们之间的最短路长度。以后逐步尝试在原路径中加入顶点k(k=0,1,…,n-1)作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。 算法描述：定义一个n阶方阵序列$A^{(-1)},A^{(0)},…,A^{(n-1)}$，其中$$A^{(-1)}[i][j]=arcs[i][j]$$$$A^{(k)}[i][j]=Min{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j]},k=0,1,…,n-1$$ 式中，$A^{(0)}[i][j]$是从顶点$v_i$到$v_j$、中间顶点是$v_0$的最短路径的长度，$A^{(k)}[i][j]$是从顶点$v_i$到$v_j$、中间顶点的序号不大于k的最短路径的长度。Floyd算法是一个迭代的过程，每迭代一次，在从$v_i$到$v_j$的最短路径上就多考虑了一个顶点；经过n次迭代后，所得到的$A^{(n-1)}[i][j]$就是$v_i$到$v_j$的最短路径长度，即方阵$A^{(n-1)}$中就保存了任意一对顶点之间的最短路径长度 算法复杂度为$O(|V|^3)$ 代码 12345for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j]; 不能解决带有“负权回路”（或者叫“负权环”）的图，因为带有“负权回路”的图没有最短路 网络流AOV网络（用顶点表示活动的网络）有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图 AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，简称AOV网 边的起点是终点的先决条件，拓扑序列不破坏先决条件 拓扑排序：在凸轮中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序 每个顶点出现且只出现一次 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径 生成拓扑排序的步骤： 选择一个入度为0的顶点 把它加入序列 把这个顶点和它发出的边从图里删除 重复以上步骤知道图里没有顶点 AOE网络（用边表示活动的网络）有向边：活动顶点：指示活动的开始和结束Number：权值 AOE网络的性质： 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始 只有在进入某一顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生 AOE网络可用于求关键路径仅有一个入度为0的顶点，称为源点，仅有一个出度为0的顶点，称为汇点 从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，关键路径上的活动称为关键活动 寻找关键活动会用到的参量： 最早开始时间 e(ai) 最晚开始时间 l(ai)：不影响后续活动的开始时间的最晚时间 l(ai)-e(ai)越大代表事件ai越不重要，越小越重要 第六章 查找查找的基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程 查找表（查找结构）：用于查找的数据集合称为查找表。操作有4种：1.查询某个特定的数据元素是否在查找表中 2. 检索满足条件的某个特定的数据元素的各种属性 3. 在查找表中插入一个数据元素 4. 从查找表中删除某个数据元素 静态查找表：只涉及上面1,2两种操作的查找表。反之则称为动态查找表。适合静态查找表的方法有顺序查找、折半查找、散列查找等；适合动态查找表的方法有二叉排序树的查找、散列查找等 关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找 平均查找长度：所有查找过程中进行关键字的比较次数的平均值，数学定义为$$ASL=\\sum^n_{i=1}P_iC_i$$n是查找表的长度；Pi是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即Pi=1/n；Ci是找到第i个数据元素所需进行的比较次数 顺序查找顺序查找也称线性查找 1. 一般线性表的顺序查找基本思想：从线性表的一端开始，逐个检查关键字是否满足给定的条件。算法如下： 12345678910typedef struct { //查找表的数据结构 ElemType *elem; //元素存储空间基址，建表时按实际长度分配，0号单元留空 int TableLen; //表的长度}SSTable;int Search_Seq(SSTable ST,ElemType key) { //在顺序表ST中顺序查找关键字为key的元素。若找到则返回该元素在表中的位置 ST.elem[0]=key; //哨兵 for(int i=ST.TableLen;ST.elem[i]!=key;--i); //从后往前找 return i; //若表中不存在关键字为key的元素，将查找到i为0时退出for循环} 在上述算法中，将ST.elem[0]称为“哨兵”。引入它的目的是使得Search_Seq内的循环不必判断数组是否会越界，因为满足i==0时，循环一定会跳出。引入“哨兵”并不是这个算法独有的 缺点：当n较大时，平均查找长度较大，效率低 优点：对数据元素的存储没有要求，顺序存储或链式存储都可。对表中记录的有序性也没有要求，无论记录是否按关键码有序，均可应用 注意，对线性的链表只能进行顺序查找 2. 有序表的顺序查找假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key，当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，这事就可返回查找失败的信息 可用判定树来描述有序顺序表的查找过程。树中的圆形结点表示有序顺序表中存在的元素；树中的矩形结点称为失败结点（注意，若有n个查找成功结点，则必定相应地有n+1个查找失败结点），它描述的是那些不在表中的数据值的集合 折半查找折半查找又称二分查找，它仅适用于有序的顺序表 算法如下： 1234567891011121314int Binary_Search(SeqList L,ElemType key) { //在有序表L中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1 int low=0,high=L,TableLen-1,mid; while(low&lt;=high) { mid=(low+high)/2; //取中间位置 if(L.elem[mid]==key) return mid; //查找成功则返回所在位置 else if(L.elem[mid]&gt;key) high=mid-1; //从前半部分继续查找 else low=mid+1; //从后半部分继续查找 } return -1;} 分块查找分块查找又称索引顺序查找，它吸收了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找 基本思想：将查找表分为若干子块，块内的元素可以无序，但块之间是有序的，而第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列 分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找 B树和B+树B树及其基本操作B树，本质为m叉搜索树，有助于减少硬盘读取，m称为B树的阶 一棵m阶B树或为空树，或满足以下要求 树中每个结点至多有m棵子树（即至多含有m-1个关键字） 若根结点不是终端结点，则至少有两棵子树 除根结点外的所有非叶结点至少有[m/2]（向上取整）棵子树（即至少含有[m/2]-1个关键字） 所有非叶子结点的结构如下： n P0 K1 P1 K2 P2 ... Kn Pn 其中，$K_i(i=1,2,…,n)$为结点的关键字，且满足$K_1&lt;K_2&lt;…&lt;K_n$；$P_i(i=0,1,…,n)$为指向子树根结点的指针，且指针$P_{i-1}$所指子树中所有结点的关键字均小于$K_i$，$P_i$所指子树中所有结点的关键字均大于$K_i$，$n（[m/2]-1\\leqslant n\\leqslant m-1）$为结点中关键字的个数 所有叶子结点在同一层 B树的插入每次都插入到叶子结点，如果结点所含关键字超过个数限制，取中间的上移，假如有偶数个，就取小的那个，如果上一层也满了，继续取中间的上移 向4阶B树中依次插入6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4，动画如下： B树的删除叶子结点直接删 内部结点，找下一层比它大的最小数上移至它的位置 如果删后结点关键字个数太少，打破了[m/2]-1的规则，此时如果左右兄弟结点有多余的结点，则借给它，如果没有，则从父结点借 详细情况见此链接：B树的删除操作，5种情况图解 B+树的基本概念一种B树的变形树 一棵m阶B+树满足下列条件 每个分支结点最多有m棵子树 非叶子根结点至少有两棵子树，其他每个分支结点至少有[m/2]棵子树 结点的子树个数与关键字个数相等 所有叶子结点包含全部关键字及指向相应记录的指针，叶子结点中将关键字按大小顺序排列，并且相邻叶子结点按大小顺序相互链接起来 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针 B+树和B树的区别在于 非叶子结点只起到索引作用，不包含具体数据 每个关键字对应一棵子树 每个结点的关键字范围为$[m/2]\\leqslant n\\leqslant m$ 叶子结点包含了全部关键字，即在非叶子结点中出现的关键字也会出现在叶子结点中 下图为一个4阶B+树的例子 散列（哈希）词典存储了很多的键值对，能够更快地搜索单词名：键 解释：值 散列查找比二分查找更快，拥有常数级的时间复杂度 散列表（Hash table）支持操作： 查找 插入 删除 数据间没有线性关系，因此不支持以下操作： 求最小值或最大值 找前驱后继数据 找一个范围内的数据 按顺序列出数据 不可行的思路全部键值和位置一一对应 浪费空间 可行的思路数据的可能取值范围为N，实际为K散列表的大小设为大于K（多一些），小于N（远远小于）的M，即M&lt;&lt;N K个数怎么存到M中通过散列函数 $H(k)$ 计算出相应位置（散列地址）$H(K_i)$ 散列函数一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr（这里的地址可以是数组下标、索引或内存地址等） 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，发生冲突的不同关键字称为同义词。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法 散列函数的构造方法在构造散列函数时，必须注意以下几点： 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址 1. 直接定址法直接去关键字的某个线性函数值为散列地址，散列函数为$$H(key)=a\\times key+b$$ 式中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费 2. 除留余数法最简单、最常用。假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为$$H(key)=key\\mod p$$ 除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突 3. 数字分析法设关键字是r进制数，则r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数 4. 平方取中法顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要根据实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数 5. 折叠法将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中的每位上数字分布大致均匀时，可以采用折叠法得到散列地址 方法2是重点 实际情况中会用String作为key 方法1：把字符的ASCII码相加。缺点是但不能均匀分布 方法2：取前三个字母的ASCII码值 方法3：将所有字符的ASCII值乘以权重相加 处理冲突的方法1. 分离链法（拉链法、链接法、chaining）把所有散列地址一样的放入一条链表中 2. 开放定址法发生冲突时存到别的位置 数学递推公式为$$H_i=(H(key)+d_i)\\mod m$$ 其中，$i=0,1,2,…,k(k\\leqslant m-1)$；$m$代表散列表表长；$d_i$为增量序列 怎么找其他位置？ 线性探测法 Linear probing$d_i=0,1,2,…,m-1$ 问题：冲突太多，每次都会争夺后一个元素的位置，容易形成簇 一般不用 平方探测法$d_i=i^2$ 问题：初始地址一样的探测地址也一样，会形成二次簇 双散列法（再散列法）定义两个散列函数。一个求散列地址，一个$Hash_2(key)$。每次往下谈$Hash_2(key)$ 当通过第一个散列函数H(key)得到的地址发生冲突时，则利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量。它的具体散列函数形式如下：$$H_i=(H(key)+i\\times Hash_2(key))\\mod m$$ i代表冲突的次数，初始为0.双散列法中，最多经过m-1次探测就会遍历表中所有位置，回到$H_0$位置 伪随机序列法$d_i$为伪随机数序列时 实际上平方探测法用的最多 注意：在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会截断其他具有相同散列地址的元素的查找地址 第七章 排序概念 稳定性：两个关键字同等的元素，排序前后相对的顺序不变。说明不稳定性只要举出反例即可。 具有稳定性的算法：直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序 不稳定的算法：希尔排序、快速排序、简单交换排序、堆排序 内部排序：在排序期间元素全部存放在内存中。 外部排序：在排序期间元素无法全部同时存放在内存中，必须根据需要不断地在内存、外村之间移动。外部排序一般是文件太大，必须存放在磁盘上。 插入排序 直接插入排序 特点：待排序数组一部分是有序的，另一部分是无序的。 时间效率：当数组元素有序时，$f(n)=O(n)$。一般情况下，$f(n)=O(n^2)$。 折半插入排序 主要针对直接插入排序的定位算法进行优化。定位更快，插入不变。 时间效率：$f(n)=O(n^2)$。 希尔排序 设置步长d将表分块，在不同块中使用直接插入排序，逐步缩小d指到1。 不稳定的算法 仅适用于顺序存储的线性表 时间效率：较佳情况下$f(n)=O(n^{1.3})$，最坏情况$f(n)=O(n^2)$。 交换排序 冒泡排序 时间效率：当数组元素有序时，$f(n)=O(n)$。一般情况下$f(n)=O(n^2)$。 快速排序 通过一趟排序将排序表划分为左右两部分，使得左边所有元素小于右边所有元素。从前往后查看元素，标记为i；从后往前查看元素，标记为j。先从j开始，如果a[j]&gt;a[i],则j–；否则swap（a[i],a[j]）,并将主动权给到i。从i开始后，如果a[j]&gt;a[i],则i++；否则swap（a[i],a[j]）,并将主动权还给j。最后直到满足一轮排序的要求。 效率：当数组元素有序时，$f(n)=O(n^2)$。一般情况下，$f(n)=O(n*log_2n)$ 在快排中，不会产生有序序列，但每趟排序会将一个元素放到最终位置上。 选择排序 简单选择排序 每一趟选一个最小的放到最前面 堆排序 堆的定义：n个关键字序列$L[1…n]$称为堆，当且仅当该序列满足其中一条： $L(i)\\leqslant L(2i)$且$L(i)\\leqslant L(2i+1)$ $L(i)\\geqslant L(2i)$且$L(i)\\geqslant L(2i+1)$ 小根堆：最小元素存放在根结点中，对任意非根结点，它的值$\\geqslant$其双亲结点的值。 堆排序：一种树形排序方法，将$L[1…n]$看作一棵完全二叉树的顺序存储结构。 堆的构造：先按初始序列建造成完全二叉树的形式，再进行调整，反复调整。 堆的删除：只能删除堆顶元素，删除前先将最后一个元素和堆顶元素交换，再向下调整。 堆的插入：插入在堆的末端，再向上调整。 空间复杂度：$O(1)$ 时间复杂度：建堆时间$O(n)$，调整时间$O(h)$。排序时间始终是$O(nlog_2n)$。 归并排序 归并：将两个或两个以上的有序表组合成一个新的有序表。 空间复杂度：$O(n)$ 时间复杂度：每趟归并$O(n)$，归并次数$log_2n$。最终时间$O(nlog_2n)$。 优点： 归并排序的效率达到了巅峰：时间复杂度为O(nlogn)，这是基于比较的排序算法所能达到的最高境界 归并排序是一种稳定的算法（即在排序过程中大小相同的元素能够保持排序前的顺序，3212升序排序结果是1223，排序前后两个2的顺序不变），这一点在某些场景下至关重要 归并排序是最常用的外部排序方法（当待排序的记录放在外存上，内存装不下全部数据时，归并排序仍然适用，当然归并排序同样适用于内部排序） 基数排序 多关键字排序思想。对单关键字采用“分配”和“收集”两种操作。 r是辅助存储空间，即r个队列。n是n个元素。 空间复杂度：$O(r)$ 时间复杂度：$O(d(n+r))$ d是关键字位数 总结1） 快速排序和堆排序相比，选择堆排序的理由： 快排需要使用递归栈，堆排序辅助空间只有$O(1)$。 快排最慢可达到$O(n^2)$，堆排序始终是$O(nlog_2n)$。","link":"notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"Web-CSS","text":"黑马程序员CSS笔记 CSS(Cascading Style Sheets) CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 CSS样式规则使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下： 12345678在上面的样式规则中:1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。2.属性和属性值以“键值对”的形式出现。3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。4.属性和属性值之间用英文“:”连接。5.多个“键值对”之间用英文“;”进行区分。可以用段落 和 表格的对齐的演示。 CSS字体样式属性font-size:字号大小font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下： font-family:字体font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码： p{ font-family:”微软雅黑”;} 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 常用技巧： 1234561. 现在网页中普遍使用14px+。2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。3. 各种字体之间必须使用英文状态下的逗号隔开。4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。 方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。font-family: “\\5FAE\\8F6F\\96C5\\9ED1”，表示设置字体为“微软雅黑”。 可以通过escape() 来测试属于什么字体。 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weight:字体粗细字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 1font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。 小技巧： 1数字 400 等价于 normal，而 700 等价于 bold。 但是我们更喜欢用数字来表示。 font-style:字体风格字体倾斜除了用 i 和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 小技巧： 1平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 font:综合设置字体样式 (重点)font属性用于对字体样式进行综合设置，其基本语法格式如下： 1选择器{font: font-style font-weight font-size/line-height font-family;} 1234使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 开发者工具（chrome）此工具是我们的必备工具，以后代码出了问题，我们首先第一反应就是： “按F12”或者是 “shift+ctrl+i” 打开 开发者工具。 菜单： 右击网页空白出—查看 小技巧： ctrl+滚轮 可以 放大开发者工具代码大小。 左边是HTML元素结构 右边是CSS样式。 右边CSS样式可以改动数值和颜色查看更改后效果。 选择器（重点）要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）。 如上图所以，要把里面的小黄人分为2组，最快的方法怎办？ 很多， 比如 一只眼睛的一组，剩下的一组 这就用到基础选择器组： 标签选择器（元素选择器）标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下： 12标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 或者元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。 课堂案例： 传智简介 类选择器类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： 1.类名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 1标签调用的时候用 class=“类名” 即可。 类选择器最大的优势是可以为元素对象定义单独或相同的样式。 小技巧： 121.长名称或词组可以使用中横线来为选择器命名。2.不建议使用“_”下划线来命名CSS选择器。 ​ 输入的时候少按一个shift键; 浏览器兼容问题 (比如使用_tips的选择器命名，在IE6是无效的) 能良好区分JavaScript变量命名(JS变量命名是用“_”) 13.不要纯数字、中文等命名， 尽量使用英文字母来表示。 猜谜底游戏： 你猜？ 命名规范： 见附件（Web前端开发规范手册.doc） 命名是我们通俗约定的，但是没有规定必须用这些常用的命名。 课堂案例： 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; span { font-size: 100px; } .blue { color: blue; } .red { color: red; } .orange { color: orange; } .green { color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=&quot;blue&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;red&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;orange&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;blue&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;red&quot;&gt;e&lt;/span&gt; &lt;/body&gt; 多类名选择器我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 121. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。2. 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 1234&lt;div class=&quot;pink fontWeight font20&quot;&gt;亚瑟&lt;/div&gt;&lt;div class=&quot;font20&quot;&gt;刘备&lt;/div&gt;&lt;div class=&quot;font14 pink&quot;&gt;安其拉&lt;/div&gt;&lt;div class=&quot;font14&quot;&gt;貂蝉&lt;/div&gt; id选择器id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下： 1#id名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 通配符选择器通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下： 1* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* { margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/} 注意： 这个通配符选择器，就像我们的电影明星中的梦中情人， 想想它就好了，但是它不会和你过日子。 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 1为了和我们刚才学的类选择器相区别， 类选择器是一个点 比如 .demo {} 而我们的伪类 用 2个点 就是 冒号 比如 :link{} 链接伪类选择器 :link /* 未访问的链接 */ :visited /* 已访问的链接 */ :hover /* 鼠标移动到链接上 */ :active /* 选定的链接 */ 注意写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包包 非常 hao 12345678a { /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; }a:hover { /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */} 结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式 123456789li:first-child { /* 选择第一个孩子 */ color: pink; }li:last-child { /* 最后一个孩子 */ color: purple; }li:nth-child(4) { /* 选择第4个孩子 n 代表 第几个的意思 */ color: skyblue; } 目标伪类选择器(CSS3) :target目标伪类选择器 :选择器可用于选取当前活动的目标元素 1234:target { color: red; font-size: 30px;} CSS注释1CSS规则是使用 /* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。 例如： 123p { font-size: 14px; /* 所有的字体是14像素大小*/} CSS外观属性color:文本颜色color属性用于定义文本的颜色，其取值方式有如下3种： 1.预定义的颜色值，如red，green，blue等。 2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。 3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 line-height:行间距ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 一般情况下，行距比字号大7.8像素左右就可以了。 text-align:水平对齐方式1text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下： left：左对齐（默认值） right：右对齐 center：居中对齐 text-indent:首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 letter-spacing:字间距letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing:单词间距word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。 颜色半透明(css3)文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下： 1color: rgba(r,g,b,a) a 是alpha 透明的意思 取值范围 0~1之间 color: rgba(0,0,0,0.3) 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子 1text-shadow:水平位置 垂直位置 模糊距离 阴影颜色; 前两项是必须写的。 后两项可以选写。 sublime快捷方式sublime可以快速提高我们代码的书写方式 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 引入CSS样式表（书写位置）CSS可以写到那个位置？ 是不是一定写到html文件里面呢？ 行内式（内联样式）是通过标签的style属性来设置元素的样式，其基本语法格式如下： 1&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt; 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。 内部样式表（内嵌式）内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： 12345&lt;head&gt;&lt;style type=&quot;text/CSS&quot;&gt; 选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;}&lt;/style&gt;&lt;/head&gt; 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。 外部样式表（外链式）链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下： 123&lt;head&gt; &lt;link href=&quot;CSS文件的路径&quot; type=&quot;text/CSS&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt; 注意： link 是个单标签哦!!! 该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下： 123href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 三种样式表总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内嵌样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 标签显示模式（display） 非洲黑人： 皮肤内黑色素含量高，以吸收阳光中的紫外线，保护皮肤内部结构免遭损害，头发象羊毛一样卷曲，使每根卷发周围都有许多空隙，空隙充满空气，卷发有隔热作用。 欧洲白人： 生活寒带或着是说常年温度较低的地缘,加上年日照时间少，身体的黑色素沉淀比较少``所以出现皮肤、发色、瞳晕都呈现浅色 传智黄人： 我中间的。。。 最重要的总结： 是为了更好的适应环境而完成的自然选择。 同理，我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(显示模式) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下： 块级元素(block-level)每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 1常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 1常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。 我一样重要 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。（a特殊） 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 链接里面不能再放链接。 块级元素和行内元素区别12345块级元素的特点：（1）总是从新行开始（2）高度，行高、外边距以及内边距都可以控制。（3）宽度默认是容器的100%（4）可以容纳内联元素和其他块元素。 12345行内元素的特点：（1）和相邻行内元素在一行上。（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。（3）默认宽度就是它本身内容的宽度。（4）行内元素只能容纳文本或则其他行内元素。 行内块元素（inline-block）123456在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。行内块元素的特点：（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。 三者的 形状 显示模式 形状 图片 块级元素 面包 行内元素 牛奶 行内块元素 果冻 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。 交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 1比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。 并集选择器并集选择器（CSS选择器分组）是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 记忆技巧： 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。 1比如 .one, p , #test {color: #F00;} 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 他和他，在一起， 在一起 一起的意思 后代选择器后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。 白话： 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 1比如： .demo &gt; h3 {color: red;} 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 测试题12345678910111213&lt;div class=&quot;nav&quot;&gt; &lt;!-- 主导航栏 --&gt; &lt;ul&gt; &lt;li&gt;公司首页&lt;/li&gt; &lt;li&gt;公司简介&lt;/li&gt; &lt;li&gt;公司产品&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; 收藏本站 &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;sitenav&quot;&gt; &lt;!-- 侧导航栏 --&gt; &lt;div class=&quot;site-l&quot;&gt;左侧侧导航栏&lt;/div&gt; &lt;div class=&quot;site-r&quot;&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; 在不修改以上代码的前提下，完成以下任务： 链接 登录 的颜色为红色。 主导航栏里面的文字颜色为绿色。 主导航栏和侧导航栏里面文字都是16像素并且是微软雅黑。 收藏本站 要求字体加粗。 属性选择器 **选择器 **示例 **含义 E[attr]**** 存在attr属性即可 E[attr=val]**** 属性值完全等于val E[attr*=val]**** 属性值里包含val字符并且在“任意”位置 E[attr^=val]**** 属性值里包含val字符并且在“开始”位置 E[attr$=val]**** 属性值里包含val字符并且在“结束”位置 123456789101112131415161718192021222324252627282930/* 获取到 拥有 该属性的元素 */li[type] { border: 1px solid gray;}/* 获取 属性等于某个值的 元素 属性值 可以使用 引号进行包裹 */li[type=&quot;vegetable&quot;] { background-color: green;}/* 使用空格分隔的 多个属性 其中有某个属性即可获取 */li[type~=&quot;hot&quot;] { font-size: 40px;}/* 获取以某个属性开头的语法 */li[color^='green'] { background-color: orange;}/* 获取以某个值 结尾的属性 */li[type$='t']{ color: hotpink; font-weight: 900;}/* 获取 属性中 拥有某个值的 元素 */li[type*=ea] { font-size: 100px;}/* 如果属性的值 只有very 也能够获取 用来获取 多个属性 并且 使用-连接 */li[price|='very'] { background-color: darkred;} 12345678910&lt;ul&gt; &lt;li type='fruit' color='green'&gt;西瓜&lt;/li&gt; &lt;li type='vegetable' color='greenyellow'&gt;西兰花&lt;/li&gt; &lt;li type='meat'&gt;牛肉&lt;/li&gt; &lt;li type='meat hot'&gt;猪肉&lt;/li&gt; &lt;li type='drink hot'&gt;可乐&lt;/li&gt; &lt;li type='drink hot'&gt;雪碧&lt;/li&gt; &lt;li price='very-cheap'&gt;红酒&lt;/li&gt; &lt;li price='very'&gt;白酒&lt;/li&gt;&lt;/ul&gt; 伪元素选择器（CSS3) E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； 1234567891011121314p::first-letter { font-size: 20px; color: hotpink;}/* 首行特殊样式 */p::first-line { color: skyblue;}p::selection { /* font-size: 50px; */ color: orange;} 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 123456div::befor { content:&quot;开始&quot;;}div::after { content:&quot;结束&quot;;} E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 E:after、E:before后面的练习中会反复用到，目前只需要有个大致了解 “:” 与 “::” 区别在于区分伪类和伪元素 CSS 背景(background)CSS 可以添加背景颜色和背景图片，以及来进行图片设置。 background-color 背景颜色 background-image 背景图片地址 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景固定还是滚动 背景的合写（复合属性） background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景图片(image)语法： 1background-image : none | url (url) 参数： none : 无背景图（默认的）url : 使用绝对或相对地址指定背景图像 background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat）语法： 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数： repeat : 背景图像在纵向和横向上平铺（默认的） no-repeat : 背景图像不平铺 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 背景位置(position)语法： 1234background-position : length || lengthbackground-position : position || position 参数： length : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位position : top | center | bottom | left | center | right 说明： 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。 注意： position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top; 则 15px 一定是 x坐标 top是 y坐标。 实际工作用的最多的，就是背景图片居中对齐了。 背景附着语法： 1background-attachment : scroll | fixed 参数： scroll : 背景图像是随对象内容滚动fixed : 背景图像固定 说明： 设置或检索背景图像是随对象内容滚动还是固定的。 背景简写background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 1background: transparent url(image.jpg) repeat-y scroll 50% 0 ; 背景透明(CSS3)CSS3支持背景半透明的写法语法格式是: 1background: rgba(0,0,0,0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。 同样， 可以给 文字和边框透明 都是 rgba 的格式来写。 12color:rgba(0,0,0,0.3);border: 1px solid rgba(0,0,0,0.3); 背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下： a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高） b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。 c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。 1234background-image: url('images/gyt.jpg'); background-size: 300px 100px; /* background-size: contain; */ /* background-size: cover; */ 多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 1background-image: url('images/gyt.jpg'),url('images/robot.png'); CSS 三大特性层叠 继承 优先级 是我们学习CSS 必须掌握的三个特性。 CSS层叠性所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。 1CSS最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 CSS继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 1CSS最后的执行口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 注意： 1恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性） CSS优先级定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。 在考虑权重时，初学者还需要注意一些特殊的情况，具体如下： 1234567继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下： specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 继承或者* 的贡献值 0,0,0,0 每个元素（标签）贡献值为 0,0,0,1 每个类，伪类贡献值为 0,0,1,0 每个ID贡献值为 0,1,0,0 每个行内样式贡献值 1,0,0,0 每个!important贡献值 ∞ 无穷大 比如的例子： 123456789div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,1 ​ 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 总结优先级： 使用了 !important声明的规则。 内嵌在 HTML 元素的 style属性里面的声明。 使用了 ID 选择器的规则。 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。 使用了元素选择器的规则。 只包含一个通用选择器的规则。 1总结：权重是优先级的算法，层叠是优先级的表现 盒子模型（CSS重点）其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。要求这三部分，无论如何也要学的非常精通。 所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 看透网页布局的本质网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？ 牛奶是怎样运输，让消费者购买的呢？ 我们说过，行内元素比如 文字 类似牛奶，也需要一个盒子把他们装起来，我们前面学过的双标签都是一个盒子。有了盒子，我们就可以随意的，自由的，摆放位置了。 看透网页布局的本质： 把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。 CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。 盒子模型（Box Model）这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。 CSS3的 盒子模型 我们后面会讲。 首先，我们来看一张图，来体会下什么是盒子模型。 所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。 盒子边框（border）边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。 语法： 1border : border-width || border-style || border-color 边框属性—设置边框样式（border-style） 边框样式用于定义页面中边框的风格，常用属性值如下： 123456789none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线dotted：边框为点线double：边框为双实线 表格的细线边框以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 让我们真的相信，CSS就是我们的白马王子（白雪公主）。 table{ border-collapse:collapse; } border-collapse:collapse; 表示边框合并在一起。 盒子边框总结表 设置内容 样式属性 常用属性值 上边框 border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; 下边框 border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; 左边框 border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; 右边框 border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; 样式综合设置 border-style:上边 [右边 下边 左边]; none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 宽度综合设置 border-width:上边 [右边 下边 左边]; 像素值 颜色综合设置 border-color:上边 [右边 下边 左边]; 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) 边框综合设置 border:四边宽度 四边样式 四边颜色; 圆角边框(CSS3)从此以后，我们的世界不只有矩形。 语法格式： 1Border-radius: 水平半径/垂直半径； 一般我们垂直半径都是省略的默认和水平半径一样。 1border-radius: 左上角 右上角 右下角 左下角; 课堂案例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; div { width:200px; height:200px; border:1px solid red; margin:10px 40px; text-align: center; line-height: 200px; } div:first-child { border:10px solid red; border-radius: 20px/50px; } div:nth-child(2) { border-radius: 20px; } div:nth-child(3) { border-radius: 15px 0; } div:nth-child(4) { border-radius:100px; } div:nth-child(5) { border-radius: 50%; } div:nth-child(6) { border-radius: 100px 0; } div:nth-child(7) { border-radius: 200px 0 0 0; } div:nth-child(8) { border-radius: 100px 100px 0 0; height:100px; /*高度减半*/ } div:nth-child(9) { border-radius: 100px; height:100px; } div:nth-child(10) { border-radius: 100%; height:100px; }&lt;/style 内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。 panda padding-top:上内边距 padding-right:右内边距 padding-bottom:下内边距 padding-left:左内边距 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 2个值 padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 3个值 padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 4个值 padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 课堂案例： 新浪导航 外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。 margin-top:上外边距 margin-right:右外边距 margin-bottom:下外边距 margin-left:上外边距 margin:上外边距 右外边距 下外边距 左外边 取值顺序跟内边距相同。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件： 必须是块级元素。 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto，就可使块级元素水平居中。 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header{ width:960px; margin:0 auto;} 清除元素的默认内外边距为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： 1234* { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */} 注意： 行内元素是只有左右内外边距的，是没有上下内外边距的。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案： 避免就好了。 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案： 可以为父元素定义1像素的上边框或上内边距。 可以为父元素添加overflow:hidden。 待续。。。。 content宽度和高度使用宽度属性width和高度属性height可以对盒子的大小进行控制。 width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。 大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是： 1盒子的总宽度= width+左右内边距之和+左右边框宽度之和+左右外边距之和 1盒子的总高度= height+上下内边距之和+上下边框宽度之和+上下外边距之和 注意： 1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。 2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。 三个计算题1231. .demo{width:200px;height:200px;border:1px solid red; padding:20px;}， 盒子最终占有的空间是多大？2. 一个盒子需要占用的空间是 400像素， 但是盒子又有 padding:25px, border: 1px solid red; 问，我们需要改动盒子宽度为多少？3. 如何让一个200 * 200像素的盒子， 在一个400 * 400的盒子里面水平居中，垂直居中。 盒子模型布局稳定性开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？ 答案是： 其实他们大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 但是，总有一个最好用的吧，我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： 1、box-sizing: border-box 盒子大小为 width 2、box-sizing: content-box 盒子大小为 width + padding + border 注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。 12345678910111213141516171819div { width: 100px; height: 100px; background: skyblue; margin: 0 auto; border: 1px solid gray; /* 默认的设置 如果我们添加了 border属性 该容器的大小会发生改变 因为他要优先保证内部的内容所占区域 不变 */ /* box-sizing 如果不设置 默认的值 就是 content-box: 优先保证内容的大小 对盒子进行缩放; border-box: 让 盒子 优先保证自己所占区域的大小,对内容进行压缩; */ box-sizing: border-box;} 盒子阴影语法格式： 1box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 但是不能写 默认 想要内阴影 inset 1234img { border:10px solid orange; box-shadow:3px 3px 5px 4px rgba(0,0,0,1);} 浮动(float)普通流(normal flow)这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。 前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？ CSS的定位机制有3种：普通流（标准流）、浮动和定位。 html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动(float)浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。 后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。（CSS3已经我们真正意义上的网页布局，具体CSS3我们会详细解释） 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。 在CSS中，通过float属性来定义浮动，其基本语法格式如下： 1选择器{float:属性值;} 属性值 描述 left 元素向左浮动 right 元素向右浮动 none 元素不浮动（默认值） 浮动详细内幕特性1浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 1浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 1由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 1浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 1元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少 1浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮漏特 浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。特： 特别注意，这是特殊的使用，有很多的不好处，使用要谨慎。 清除浮动 人生就像乘坐北京地铁一号线： 途经国贸，羡慕繁华； 途经天安门，幻想权力； 途经金融街，梦想发财； 经过公主坟，遥想华丽家族； 经过玉泉路，依然雄心勃勃… 这时，有个声音飘然入耳:乘客你好,八宝山马上就要到了！ 顿时醒悟：人生苦短，有始有终。 好比我们的浮动，有浮动开始，则就应该有浮动结束。 为什么要清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。 如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 1选择器{clear:属性值;} 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 额外标签法1是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） 1可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动使用方法： 123.clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 使用before和after双伪元素清除浮动使用方法： 12345678910.clearfix:before,.clearfix:after { content:&quot;.&quot;; display:table;}.clearfix:after { clear:both;}.clearfix { *zoom:1;} 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 版心和布局流程阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。 “版心”是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML页面，CSS文件。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中 最普通的，最为常用的结构 两列左窄右宽型 比如小米 小米官网 通栏平均分布型 比如锤子 锤子官网 Photoshop Photoshop基本使用PS界面组成：菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口​ 窗口菜单，可显示隐藏所有面板 工作区：（新建） 1、调整浮动面板 2、选项栏后方，新建工作区，命名。 删除工作区：先选择其他工作区，再操作删除工作区。 基本操作文件下拉菜单：​ 1、新建 新建文档 CTRL+N 单位：像素 厘米 毫米 屏幕显示： 单位 像素 72像素/英寸 RGB颜色模式 印刷行业： 单位 CM/MM 300像素/英寸 CMYK颜色模式 2、关闭文档 CTRL+W 3、存储 CTRL+S （替存） 4、存储为 CTRL+SHIFT+S 另存一份文件 5、格式：​ .psd PS源文件格式 图层、文字、样式等，可再次编辑​ （给自己）​ .jpg 有损压缩格式 （给客户） 品质 最高12 6、文件打开：​ 1）文件下拉菜单-打开（CTRL+O欧）（双击软件空白处=打开）​ 2）拖拽文件至选项栏上方，释放鼠标 移动工具 V1、不同文件之间拖拽图像。 图层操作 图层面板快捷键 F7 图层选择： 使用移动工具V 1、图层缩览图判断 2、按住CTRL,在目标图像上单击 3、将光标放置在目标图像上右键，选择图层名称 图层面板中加选图层： 1、按SHIFT，单击另一目标图层 中间所有图层被选中 2、按CTRL，单击另一目标图层 只选中目标图层 复制图层：选中目标图层后（移动工具状态下） 1、按ALT拖拽图像 2、CTRL+J （重合） 3、拖拽目标至创建新图层按钮 图层编组选中目标图层，CTRL+G 取消编组：CTRL+SHIFT+G 双击图层名称可重新命名 双击组名称，可命名组 移动工具V选择组或图层时，需设置选项栏 图层上下位置移动1、选中目标图层，在图层面拖拽 2、CTRL+] 向上移动图层​ CTRL+[ 向下移动图层 3、CTRL+SHIFT+] 图层置顶​ CTRL+SHIFT+[ 图层置底 移动选区或图像时： 移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。 图层透明度不透明度：设置图层的不透明程度 0%完全透明，不可见 ​ 100%完全不透明，真实可见 填充：与不透明度效果类似 ) 键盘数字键，可快速设置透明度数值 套索工具 L1、套索工具 L 在屏幕上拖拽鼠标左键，释放后生成选区 2、多边形套索 L 连续单击绘制多边形选区 ​ 闭合方法：1、单击起始点 2、双击任意位置 ​ DELETE删除当前点 3、磁性套索工具 L 单击颜色交界后，沿交界线拖拽鼠标，可生成选区。 磁性套索 LL 在颜色交界的位置单击后拖动。单击起始点后，生成选区。 大小写键：CAPSLOCK 可控制光标精确状态。 魔棒工具 W以单击位置为选择色，选择相似颜色生成选区。 容差：选择颜色的范围 容差小，颜色选择精确。 0-255 连续：勾选连续时，相连颜色生成选区。 ​ 不勾选，画面中所有相似颜色被选中生成选区。 按SHIFT在未生成选区位置单击，可选区相加。 选区反选：CTRL+SHIFT+I 选区布尔运算 选区面积大小的变化。 新选区：保持选中状态 添加到选区：相加运算（按住SHIFT再绘制选区） 从选区减去：相减（按住ALT再绘制选区） 与选区交叉：重合部分保留。（按住ALT+SHIFT再绘制选区） 钢笔工具： P作用：绘制路径，生成选区，抠图。 组成;路径线和锚点 绘制路径后，CTRL+回车，生成选区。 路径类型： 直线型路径：连续单击 曲线型路径：第一点单击，第二点拖动鼠标。 Photoshop 切图PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图 切片工具 利用切片工具手动划出 2.图层—新建基于图层的切片 利用标尺 基础参考线的切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 定位(position)如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。 PS: 定位是我们CSS算是数一数二难点的了，但是，你务必要学好它，我们CSS离不开定位，特别是后面的js特效，天天和定位打交道。不要抵触它，反而要爱上它，它可以让我们工作更加轻松哦！ 为什么要用定位？那么定位，最长运用的场景再那里呢？ 来看几幅图片，你一定会有感悟！ 第一幅图， 小黄色块可以再图片上移动： 第二幅图， 左右箭头压住图片： 第三幅图, hot 再盒子外面多出一块，更加突出： 以上三个小地方，如果用标准流或者浮动，实现会比较复杂或者难以实现，此时我们用定位来做，just soso！ 元素的定位属性元素的定位属性主要包括定位模式和边偏移两部分。 1、边偏移 边偏移属性 描述 top 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom 底部偏移量，定义元素相对于其父元素下边线的距离 left 左侧偏移量，定义元素相对于其父元素左边线的距离 right 右侧偏移量，定义元素相对于其父元素右边线的距离 也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px; left: 30px; 等等 2、定位模式 在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下： 选择器{position:属性值;} position属性的常用值 值 描述 static 自动定位（默认定位方式） relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元素进行定位 fixed 固定定位，相对于浏览器窗口进行定位 静态定位(static)静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。 上面的话翻译成白话： 就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。 在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。 PS： 静态定位其实没啥可说的。 相对定位relative(自恋型)12小笑话： 刚刚看到一个超级超级帅的帅哥，看得我都忍不住想和他搞基了。世间怎会有如此之完美的男人。我和他就这样一动不动的对视着，就仿佛一见钟情。时间也在这一瞬间停止了。直到我的手麻了。才恋恋不舍的放下镜子。。。。 相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。 对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示： 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。 绝对定位absolute (拼爹型)12345678小笑话：吃早饭时，老婆往儿子碗里放了两个煎蛋，儿子全给了我，还一本正经地说：“爸爸，多吃点，男人养家不容易。” &lt;br/&gt;我一阵感动，刚想夸他两句。 儿子接着说：“以后全靠你让我拼爹了！” [注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。 当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。 注意： 绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。 父级没有定位若所有父元素都没有定位，以浏览器为准对齐(document文档)。 父级有定位绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的盒子没有边偏移如果只是给盒子指定了 定位，但是没有给与边偏移，则改盒子以标准流来显示排序，和上一个盒子的底边对齐，但是不占有位置。 子绝父相这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。 这句话的意思是 子级是绝对定位的话， 父级要用相对定位。 首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。 就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。 但是，在我们网页布局的时候， 最常说的 子绝父相是怎么来的呢？ 请看如下图： 草图就是如下： 所以，我们可以得出如下结论： 因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。 父盒子布局时，需要占有位置，因此父亲只能是 相对定位. 这就是子绝父相的由来。 固定定位fixed(认死理型)固定定位是绝对定位的一种特殊形式，它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 固定定位的元素跟父亲没有任何关系，只认浏览器。 固定定位完全脱标，不占有位置，不随着滚动条滚动。 记忆法： 就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。 ie6等低版本浏览器不支持固定定位。 叠放次序（z-index）当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。 在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。 比如： z-index: 2; 注意： z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。 如果取值相同，则根据书写顺序，后来居上。 后面数字一定不能加单位。 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。 四种定位总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置 定位模式转换跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后，可以不用转换模式，直接给高度和宽度就可以了。 元素的显示与隐藏在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。 他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！ display 显示display 设置或检索对象是否及如何显示。 display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 visibility 可见性设置或检索是否显示对象。 visible : 对象可视 hidden : 对象隐藏 特点： 隐藏之后，继续保留原有位置。（停职留薪） overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 visible : 不剪切内容也不添加滚动条。 auto : 超出自动显示滚动条，不超出不显示滚动条 hidden : 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll : 不管超出内容否，总是显示滚动条 CSS高级技巧CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 1cursor : default 小白 | pointer 小手 | move 移动 | text 文本 鼠标放我身上查看效果哦： 123456&lt;ul&gt; &lt;li style=&quot;cursor:default&quot;&gt;我是小白&lt;/li&gt; &lt;li style=&quot;cursor:pointer&quot;&gt;我是小手&lt;/li&gt; &lt;li style=&quot;cursor:move&quot;&gt;我是移动&lt;/li&gt; &lt;li style=&quot;cursor:text&quot;&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 尽量不要用hand 因为 火狐不支持 pointer ie6以上都支持的尽量用 轮廓 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; 1&lt;input type=&quot;text&quot; style=&quot;outline: 0;&quot;/&gt; 防止拖拽文本域resizeresize：none 这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。 右下角可以拖拽： 右下角不可以拖拽： 1&lt;textarea style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt; vertical-align 垂直对齐以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto; 以前我们还讲过让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。 vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。 1vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片和表单等。 图片和文字对齐所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。 去除图片底侧空白缝隙有个很重要特性你要记住： 如果一个元素没有基线，比如图片或者表单等行内块元素，则他的底线会和父级盒子的基线对齐。 这样会造成一个问题，就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 CSS精灵技术（sprite）精灵技术产生的背景 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术本质简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图，如下图所示为京东网站中的一个精灵图。 精灵技术的使用CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。 制作精灵图CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 1234我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。我们精灵图的宽度取决于最宽的那个背景。 我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 字体图标图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新”宠幸”啦。。 这就是字体图标（iconfont). 字体图标优点12345可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...本身体积更小，但携带的信息并没有削减。几乎支持所有的浏览器移动端设备必备良药... 字体图标使用流程总体来说，字体图标按照如下流程： 设计字体图标假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图： 之后保存为svg格式，然后给我们前端人员就好了。 其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。 上传生成字体包 当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。 ​ 推荐网站： http://icomoon.io icomoon字库 IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 推荐网站： http://www.iconfont.cn/ 阿里icon font字库 http://www.iconfont.cn/ 这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！ fontello http://fontello.com/ 在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。 Font-Awesome http://fortawesome.github.io/Font-Awesome/ 这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。 Glyphicon Halflings http://glyphicons.com/ 这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。 Icons8 https://icons8.com/ 提供PNG免费下载，像素大能到500PX 下载兼容字体包刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了 当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。 字体引入到HTML最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。 首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法 第一步：引入项目下面生成的fontclass代码：1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/CSS&quot; href=&quot;./iconfont.CSS&quot;&gt; 第二步：挑选相应图标并获取类名，应用于页面：1&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt; 滑动门先来体会下现实中的滑动门,或者你可以叫做推拉门： 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。 核心技术核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 12345&lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 伸缩布局(CSS3)CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的 方向：默认主轴从左向右，侧轴默认从上到下 主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多 2、各属性详解**** a、flex-direction调整主轴方向（默认为水平方向） b、justify-content调整主轴对齐 c、align-items调整侧轴对齐 d、flex-wrap控制是否换行 e、align-content堆栈（由flex-wrap产生的独立行）对齐 f、flex-flow是flex-direction、flex-wrap的简写形式 g、flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 h、order控制子项目的排列顺序，正序方式排序，从小到大 此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值 过渡(CSS3)过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片 在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。 语法格式: 1transition: 要过渡的属性 花费时间 运动曲线 何时开始; 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 运动曲线示意图： 1234567img { width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%; transition:transform 0.5s ease-in 0s;}img:hover { transform:rotate(180deg);} 2D变形(CSS3)转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 变形转换 transform 移动 translate(x, y) 1translate(50px,50px); 使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。 可以改变元素的位置，x、y可为负值； 123translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）translateX(x)仅水平方向移动（X轴移动）translateY(Y)仅垂直方向移动（Y轴移动） 123456789.box { width: 499.9999px; height: 400px; background: pink; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); /* 走的自己的一半 */} 让定位的盒子水平居中 缩放 scale(x, y) 1transform:scale(0.8,1); 可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。 123scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）scaleX(x)元素仅水平方向缩放（X轴缩放）scaleY(y)元素仅垂直方向缩放（Y轴缩放） scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大 旋转 rotate(deg) 可以对元素进行旋转，正值为顺时针，负值为逆时针； 1transform:rotate(45deg); 当元素旋转以后，坐标轴也跟着发生的转变 调整顺序可以解决，把旋转放到最后 注意单位是 deg 度数 案例旋转扑克牌 12345678910111213141516171819202122232425262728293031323334353637body { background-color: skyblue;}.container { width: 100px; height: 150px; border: 1px solid gray; margin: 300px auto; position: relative;}.container &gt; img { display: block; width: 100%; height: 100%; position: absolute; transform-origin: top right; /* 添加过渡 */ transition: all 1s;}.container:hover img:nth-child(1) { transform: rotate(60deg);}.container:hover img:nth-child(2) { transform: rotate(120deg);}.container:hover img:nth-child(3) { transform: rotate(180deg);}.container:hover img:nth-child(4) { transform: rotate(240deg);}.container:hover img:nth-child(5) { transform: rotate(300deg);}.container:hover img:nth-child(6) { transform: rotate(360deg);} 倾斜 skew(deg, deg) 1transform:skew(30deg,0deg); 该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。 5.transform-origin可以调整元素转换的原点 1div{transform-origin: left top;transform: rotate(45deg); } /* 改变元素原点到左上角，然后进行顺时旋转45度 */ 案例： 菱形照片 三角盒子 3D变形左手坐标系 伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图 CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图 rotateX() 就是沿着 x 立体旋转. 1234567img { transition:all 0.5s ease 0s;}img:hove { transform:rotateX(180deg);} rotateY()沿着y轴进行旋转 1234567img { transition:all 0.5s ease 0s;}img:hove { transform:rotateX(180deg);} rotateZ()沿着z轴进行旋转 123456789img { transition:all .25s ease-in 0s;}img:hover { /* transform:rotateX(180deg); */ /* transform:rotateY(180deg); */ /* transform:rotateZ(180deg); */ /* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */} 透视(perspective)电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。 注：并非任何情况下需要透视效果，根据开发需要进行设置。 perspective有两种写法 作为一个属性，设置给父元素，作用于所有3D转换的子元素 作为transform属性的一个值，做用于元素自身 理解透视距离原理： 开门案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061body {}.door { width: 300px; height: 300px; margin: 100px auto; border: 1px solid gray; perspective: 1000px; background: url('images/dog.gif') no-repeat center/cover; position: relative;}.door &gt; div { box-sizing: border-box; border: 1px solid black;}.left { float: left; width: 50%; height: 100%; background-color: brown; transform-origin: left center; transition: 1s; position: relative;}.left::before { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; right: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;}.right { width: 50%; height: 100%; float: left; background-color: brown; transform-origin: right center; transition: 1s; position: relative;}.right::before { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; left: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;}.door:hover .left { transform: rotateY(-130deg);}.door:hover .right { transform: rotateY(130deg);} translateX(x)仅水平方向移动**（X轴移动） 主要目的实现移动效果 translateY(y)仅垂直方向移动（Y轴移动） translateZ(z)transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。 3D呈现（transform-style）设置内嵌的元素在 3D 空间如何呈现，这些子元素必须为转换原素。 flat：所有子元素在 2D 平面呈现 preserve-3d：保留3D空间 3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。 一般而言，该声明应用在3D变换的兄弟元素们的父元素上。 翻转盒子案例(百度钱包)1234567891011121314151617181920212223242526272829303132333435363738394041body { margin: 0; padding: 0; background-color: #B3C04C;}.wallet { width: 300px; height: 300px; margin: 50px auto; position: relative; transform-style: preserve-3d; transition: all 0.5s;}.wallet::before, .wallet::after { content: ''; position: absolute; left: 0; top: 0; display: block; width: 100%; height: 100%; background-image: url(./images/bg.png); background-repeat: no-repeat;}.wallet::before { background-position: right top; transform: rotateY(180deg);}.wallet::after { background-position: left top; transform: translateZ(2px);}.wallet:hover { transform: rotateY(180deg);} 动画(CSS3)动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 语法格式： 1animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向; 关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r 1234@keyframes 动画名称 { from{ 开始位置 } 0% to{ 结束 } 100%} 12animation-iteration-count:infinite; 无限循环播放animation-play-state:paused; 暂停动画&quot; 小汽车案例123456789101112131415161718192021222324252627body { background: white;}img { width: 200px;}.animation { animation-name: goback; animation-duration: 5s; animation-timing-function: ease; animation-iteration-count: infinite;}@keyframes goback { 0%{} 49%{ transform: translateX(1000px); } 55%{ transform: translateX(1000px) rotateY(180deg); } 95%{ transform: translateX(0) rotateY(180deg); } 100%{ transform: translateX(0) rotateY(0deg); }}","link":"notes/css/"}],"tags":[{"name":"专插本","slug":"专插本","link":"tags/%E4%B8%93%E6%8F%92%E6%9C%AC/"},{"name":"CSS","slug":"CSS","link":"tags/CSS/"}],"categories":[{"name":"专插本","slug":"专插本","link":"categories/%E4%B8%93%E6%8F%92%E6%9C%AC/"},{"name":"Web前端","slug":"Web前端","link":"categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"Web前端/CSS","link":"categories/Web%E5%89%8D%E7%AB%AF/CSS/"}]}